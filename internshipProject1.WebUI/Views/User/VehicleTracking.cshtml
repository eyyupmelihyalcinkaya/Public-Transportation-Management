@{
    ViewData["Title"] = "Ara√ß Takip";
    Layout = "_Layout";
}

@section Styles {
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
}

@section Scripts {
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
}

<div class="container-fluid mt-4">
    <!-- Ba≈ülƒ±k -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card glass-card">
                <div class="card-body text-center">
                    <h2 class="card-title">
                        <i class="fas fa-bus text-primary"></i>
                        Ara√ß Takip Sistemi
                    </h2>
                    <p class="card-text text-muted">Otob√ºs, metrob√ºs, metro ve diƒüer toplu ta≈üƒ±ma ara√ßlarƒ±nƒ± ger√ßek zamanlƒ± takip edin</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Ara√ß T√ºr√º Se√ßimi -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card glass-card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-filter text-info"></i>
                        Ara√ß T√ºr√º Se√ßin
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-3 mb-3">
                            <div class="vehicle-type-card modern-card" onclick="selectVehicleType('bus')">
                                <div class="vehicle-icon">
                                    <i class="fas fa-bus text-primary"></i>
                                </div>
                                <h6>Otob√ºs</h6>
                                <small class="text-muted">≈ûehir i√ßi otob√ºsler</small>
                            </div>
                        </div>
                        <div class="col-md-3 mb-3">
                            <div class="vehicle-type-card modern-card" onclick="selectVehicleType('metrobus')">
                                <div class="vehicle-icon">
                                    <i class="fas fa-subway text-success"></i>
                                </div>
                                <h6>Metrob√ºs</h6>
                                <small class="text-muted">Metrob√ºs hatlarƒ±</small>
                            </div>
                        </div>
                        <div class="col-md-3 mb-3">
                            <div class="vehicle-type-card modern-card" onclick="selectVehicleType('metro')">
                                <div class="vehicle-icon">
                                    <i class="fas fa-train text-warning"></i>
                                </div>
                                <h6>Metro</h6>
                                <small class="text-muted">Metro hatlarƒ±</small>
                            </div>
                        </div>
                        <div class="col-md-3 mb-3">
                            <div class="vehicle-type-card modern-card" onclick="selectVehicleType('tram')">
                                <div class="vehicle-icon">
                                    <i class="fas fa-train text-info"></i>
                                </div>
                                <h6>Tramvay</h6>
                                <small class="text-muted">Tramvay hatlarƒ±</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hat Se√ßimi -->
    <div class="row mb-4" id="routeSelection" style="display: none;">
        <div class="col-12">
            <div class="card glass-card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-route text-success"></i>
                        Hat Se√ßimi
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row" id="routeList">
                        <!-- Hatlar dinamik olarak y√ºklenecek -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ara√ß Takip Haritasƒ± -->
    <div class="row mb-4" id="trackingMap" style="display: none;">
        <div class="col-12">
            <div class="card glass-card">
                <div class="card-header d-flex justify-content-between align-items-center">
                                            <h5 class="mb-0">
                            <i class="fas fa-map-marker-alt text-danger"></i>
                            Se√ßilen Rota Takibi
                        </h5>
                        <div class="text-muted">
                            <small>Se√ßilen rotanƒ±n duraklarƒ± ve g√ºzergahƒ± g√∂sterilmektedir</small>
                        </div>
                </div>
                <div class="card-body">
                    <div id="map" style="height: 500px; background: #f8f9fa; border-radius: 10px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ara√ß Listesi -->
    <div class="row mb-4" id="vehicleList" style="display: none;">
        <div class="col-12">
            <div class="card glass-card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-list text-info"></i>
                        Ara√ß Listesi
                    </h5>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-hover">
                            <thead>
                                <tr>
                                    <th>Ara√ß No</th>
                                    <th>Hat</th>
                                    <th>Konum</th>
                                    <th>Hƒ±z</th>
                                    <th>Durum</th>
                                    <th>Tahmini Varƒ±≈ü</th>
                                </tr>
                            </thead>
                            <tbody id="vehicleTableBody">
                                <!-- Ara√ßlar dinamik olarak y√ºklenecek -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Durak Bilgileri -->
    <div class="row mb-4" id="stopInfo" style="display: none;">
        <div class="col-12">
            <div class="card glass-card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-map-pin text-warning"></i>
                        Durak Bilgileri
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row" id="stopList">
                        <!-- Duraklar dinamik olarak y√ºklenecek -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    .glass-card {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .vehicle-type-card {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        padding: 1.5rem;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }

    .vehicle-type-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s;
    }

    .vehicle-type-card:hover::before {
        left: 100%;
    }

    .vehicle-type-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        background: rgba(255, 255, 255, 0.2);
    }

    .vehicle-type-card.selected {
        background: rgba(13, 110, 253, 0.2);
        border-color: #0d6efd;
        box-shadow: 0 8px 25px rgba(13, 110, 253, 0.3);
    }

    /* Light tema i√ßin kartlar */
    body.light .vehicle-type-card {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: #333;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    body.light .vehicle-type-card:hover {
        background: rgba(255, 255, 255, 0.3);
        color: #000;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    body.light .vehicle-type-card.selected {
        background: rgba(13, 110, 253, 0.2);
        border-color: #0d6efd;
        color: #0d6efd;
    }

    /* Dark tema i√ßin kartlar */
    body.dark .vehicle-type-card {
        background: rgba(30, 41, 59, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        box-shadow: 0 4px 15px rgba(30, 41, 59, 0.4);
    }

    body.dark .vehicle-type-card:hover {
        background: rgba(30, 41, 59, 0.5);
        color: #fff;
        box-shadow: 0 8px 25px rgba(30, 41, 59, 0.6);
    }

    body.dark .vehicle-type-card.selected {
        background: rgba(13, 110, 253, 0.2);
        border-color: #0d6efd;
        color: #6ea8fe;
    }

    .vehicle-icon {
        font-size: 2.5rem;
        margin-bottom: 1rem;
    }

    .route-card {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1rem;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
    }

    .route-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s;
    }

    .route-card:hover::before {
        left: 100%;
    }

    .route-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        background: rgba(255, 255, 255, 0.2);
    }

    .route-card.selected {
        background: rgba(25, 135, 84, 0.2);
        border-color: #198754;
        box-shadow: 0 6px 20px rgba(25, 135, 84, 0.3);
    }

    /* Light tema i√ßin route kartlarƒ± */
    body.light .route-card {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: #333;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    body.light .route-card:hover {
        background: rgba(255, 255, 255, 0.3);
        color: #000;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    body.light .route-card.selected {
        background: rgba(25, 135, 84, 0.2);
        border-color: #198754;
        color: #198754;
    }

    /* Dark tema i√ßin route kartlarƒ± */
    body.dark .route-card {
        background: rgba(30, 41, 59, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        box-shadow: 0 4px 15px rgba(30, 41, 59, 0.4);
    }

    body.dark .route-card:hover {
        background: rgba(30, 41, 59, 0.5);
        color: #fff;
        box-shadow: 0 8px 25px rgba(30, 41, 59, 0.6);
    }

    body.dark .route-card.selected {
        background: rgba(25, 135, 84, 0.2);
        border-color: #198754;
        color: #75b798;
    }

    .vehicle-status {
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: 600;
        letter-spacing: 0.5px;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid transparent;
    }

    .status-active {
        background: rgba(25, 135, 84, 0.2);
        color: #198754;
        border-color: rgba(25, 135, 84, 0.3);
    }

    .status-active:hover {
        background: rgba(25, 135, 84, 0.3);
        transform: scale(1.05);
    }

    .status-delayed {
        background: rgba(255, 193, 7, 0.2);
        color: #ffc107;
        border-color: rgba(255, 193, 7, 0.3);
    }

    .status-delayed:hover {
        background: rgba(255, 193, 7, 0.3);
        transform: scale(1.05);
    }

    .status-stopped {
        background: rgba(220, 53, 69, 0.2);
        color: #dc3545;
        border-color: rgba(220, 53, 69, 0.3);
    }

    .status-stopped:hover {
        background: rgba(220, 53, 69, 0.3);
        transform: scale(1.05);
    }

    /* Light tema i√ßin durum g√∂stergeleri */
    body.light .vehicle-status {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    body.light .status-active {
        background: rgba(25, 135, 84, 0.2);
        color: #198754;
        border-color: rgba(25, 135, 84, 0.3);
    }

    body.light .status-delayed {
        background: rgba(255, 193, 7, 0.2);
        color: #e0a800;
        border-color: rgba(255, 193, 7, 0.3);
    }

    body.light .status-stopped {
        background: rgba(220, 53, 69, 0.2);
        color: #dc3545;
        border-color: rgba(220, 53, 69, 0.3);
    }

    /* Dark tema i√ßin durum g√∂stergeleri */
    body.dark .vehicle-status {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    body.dark .status-active {
        background: rgba(25, 135, 84, 0.2);
        color: #75b798;
        border-color: rgba(25, 135, 84, 0.3);
    }

    body.dark .status-delayed {
        background: rgba(255, 193, 7, 0.2);
        color: #ffca2c;
        border-color: rgba(255, 193, 7, 0.3);
    }

    body.dark .status-stopped {
        background: rgba(220, 53, 69, 0.2);
        color: #ea868f;
        border-color: rgba(220, 53, 69, 0.3);
    }

    .stop-item {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 0.5rem;
        transition: all 0.3s ease;
    }

    .stop-item:hover {
        background: rgba(255, 255, 255, 0.2);
    }

    .stop-item.active {
        background: rgba(13, 110, 253, 0.2);
        border-color: #0d6efd;
    }

    /* Harita popup stilleri */
    .popup-content {
        min-width: 200px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .popup-content h6 {
        margin-bottom: 0.5rem;
        color: #333;
        font-weight: 600;
        border-bottom: 1px solid #eee;
        padding-bottom: 0.25rem;
    }

    .popup-content p {
        font-size: 0.85rem;
        margin-bottom: 0.25rem;
    }

    .popup-content p:last-child {
        margin-bottom: 0;
    }

    /* Leaflet popup √∂zelle≈ütirme */
    .leaflet-popup-content-wrapper {
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .leaflet-popup-tip {
        background: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* OSM Ray √ßizgileri i√ßin stiller */
    .osm-railway {
        stroke-linecap: round;
        stroke-linejoin: round;
        filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
    }

    .osm-railway:hover {
        filter: drop-shadow(3px 3px 6px rgba(0, 0, 0, 0.4));
    }

    /* Loading indicator for OSM data */
    .route-loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 15px 25px;
        border-radius: 8px;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(5px);
    }

    .route-loading i {
        margin-right: 10px;
        color: #007bff;
    }
</style>

<script>
    let selectedVehicleType = '';
    let selectedRoute = '';
    let map = null;
    let routesData = [];
    let currentRouteLayer = null;

    // Ara√ß t√ºr√º se√ßimi - global scope'ta
    window.selectVehicleType = function(type) {
        selectedVehicleType = type;
        
        // T√ºm kartlarƒ±n se√ßimini kaldƒ±r
        document.querySelectorAll('.vehicle-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        // Se√ßilen kartƒ± i≈üaretle
        event.currentTarget.classList.add('selected');
        
        // Hat se√ßimini g√∂ster
        document.getElementById('routeSelection').style.display = 'block';
        
        // Hatlarƒ± y√ºkle
        loadRoutes(type);
    }

    // API'den rotalarƒ± y√ºkle
    async function loadRoutes(vehicleType) {
        const routeList = document.getElementById('routeList');
        routeList.innerHTML = '<div class="col-12 text-center"><i class="fas fa-spinner fa-spin"></i> Rotalar y√ºkleniyor...</div>';
        
        try {
            const response = await fetch('/User/GetPublicRoutes?page=1&pageSize=100');
            if (!response.ok) {
                throw new Error('Rotalar y√ºklenemedi');
            }
            
            const allRoutes = await response.json();
            routesData = allRoutes;
            
            // Se√ßilen ara√ß t√ºr√ºne g√∂re filtreleme
            const filteredRoutes = filterRoutesByType(allRoutes, vehicleType);
            
            routeList.innerHTML = '';
            
            if (filteredRoutes.length === 0) {
                routeList.innerHTML = `
                    <div class="col-12 text-center text-muted">
                        <i class="fas fa-info-circle mb-2"></i>
                        <p>Bu ara√ß t√ºr√º i√ßin rota bulunamadƒ±</p>
                    </div>
                `;
                return;
            }
            
            filteredRoutes.forEach(route => {
                const routeCard = document.createElement('div');
                routeCard.className = 'col-md-6 col-lg-4 mb-3';
                routeCard.innerHTML = `
                    <div class="route-card" onclick="selectRoute('${route.id}')">
                        <div class="d-flex align-items-center">
                            <div class="me-3">
                                <i class="fas fa-route text-primary"></i>
                            </div>
                            <div>
                                <h6 class="mb-1">${route.name}</h6>
                                <small class="text-muted">${route.startLocation} - ${route.endLocation}</small>
                                <br>
                                <small class="text-info">${getRouteTypeIcon(route.name)} ${getRouteTypeText(route.name)}</small>
                            </div>
                        </div>
                    </div>
                `;
                routeList.appendChild(routeCard);
            });
        } catch (error) {
            console.error('Rota y√ºkleme hatasƒ±:', error);
            routeList.innerHTML = `
                <div class="col-12 text-center text-danger">
                    <i class="fas fa-exclamation-triangle mb-2"></i>
                    <p>Rotalar y√ºklenirken hata olu≈ütu</p>
                </div>
            `;
        }
    }

    // Rota t√ºr√ºne g√∂re filtreleme
    function filterRoutesByType(routes, vehicleType) {
        return routes.filter(route => {
            const routeName = route.name.toLowerCase();
            switch (vehicleType) {
                case 'bus':
                    return routeName.includes('otob√ºs') || routeName.includes('bus') || 
                           (!routeName.includes('metro') && !routeName.includes('tramvay') && !routeName.includes('metrob√ºs'));
                case 'metro':
                    return routeName.includes('metro') && !routeName.includes('metrob√ºs');
                case 'tram':
                    return routeName.includes('tramvay') || routeName.includes('tram');
                case 'metrobus':
                    return routeName.includes('metrob√ºs') || routeName.includes('metrobus');
                default:
                    return true;
            }
        });
    }

    // Rota t√ºr√º ikonunu belirle
    function getRouteTypeIcon(routeName) {
        const name = routeName.toLowerCase();
        if (name.includes('metro') && !name.includes('metrob√ºs')) return '<i class="fas fa-train"></i>';
        if (name.includes('tramvay') || name.includes('tram')) return '<i class="fas fa-tram"></i>';
        if (name.includes('metrob√ºs') || name.includes('metrobus')) return '<i class="fas fa-subway"></i>';
        return '<i class="fas fa-bus"></i>';
    }

    // Rota t√ºr√º metnini belirle
    function getRouteTypeText(routeName) {
        const name = routeName.toLowerCase();
        if (name.includes('metro') && !name.includes('metrob√ºs')) return 'Metro';
        if (name.includes('tramvay') || name.includes('tram')) return 'Tramvay';
        if (name.includes('metrob√ºs') || name.includes('metrobus')) return 'Metrob√ºs';
        return 'Otob√ºs';
    }

    // Hat se√ßimi
    window.selectRoute = async function(routeId) {
        selectedRoute = routeId;
        
        // T√ºm hat kartlarƒ±nƒ±n se√ßimini kaldƒ±r
        document.querySelectorAll('.route-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        // Se√ßilen kartƒ± i≈üaretle
        event.currentTarget.classList.add('selected');
        
        // Takip sayfalarƒ±nƒ± g√∂ster
        document.getElementById('trackingMap').style.display = 'block';
        document.getElementById('vehicleList').style.display = 'block';
        document.getElementById('stopInfo').style.display = 'block';
        
        // Haritayƒ± ba≈ülat
        initializeMap();
        
        // Se√ßilen rotayƒ± haritada g√∂ster
        await loadRouteOnMap(routeId);
        
        // Ara√ßlarƒ± ve duraklarƒ± y√ºkle
        loadVehicles(routeId);
        loadStops(routeId);
    }

    // Se√ßilen rotayƒ± haritada g√∂ster
    async function loadRouteOnMap(routeId) {
        try {
            // √ñnceki rota layer'ƒ±nƒ± temizle
            if (currentRouteLayer) {
                map.removeLayer(currentRouteLayer);
            }

            // Rota duraklarƒ± verilerini al
            const response = await fetch(`/User/GetPublicRouteStops?routeId=${routeId}&page=1&pageSize=100`);
            if (!response.ok) {
                console.error('API Response Error:', response.status, response.statusText);
                const errorText = await response.text();
                console.error('Error details:', errorText);
                throw new Error(`Rota duraklarƒ± alƒ±namadƒ± (${response.status}): ${errorText}`);
            }

            const stops = await response.json();
            console.log('Rota duraklarƒ±:', stops);
            console.log('üîç Stop sayƒ±sƒ±:', stops?.length || 0);
            console.log('üîç Rota ID:', routeId);
            console.log('üîç Rota bilgisi:', route);

            if (stops && stops.length > 0) {
                // Rota bilgisini bul
                const route = routesData.find(r => r.id == routeId);
                const routeType = getRouteTypeFromName(route?.name || '');
                const routeColor = getRouteColor(routeType);

                // Yeni layer grup olu≈ütur
                currentRouteLayer = L.layerGroup();

                // Duraklarƒ± sƒ±rala
                const sortedStops = stops.sort((a, b) => (a.order || 0) - (b.order || 0));

                // Koordinatlarƒ± topla
                const coordinates = [];
                
                // Duraklarƒ± haritaya ekle
                console.log('üöè Stop marker\'larƒ± ekleniyor, toplam:', sortedStops.length);
                sortedStops.forEach((stop, index) => {
                    console.log(`üöè Stop ${index + 1}:`, {
                        name: stop.name,
                        lat: stop.latitude,
                        lng: stop.longitude,
                        order: stop.order
                    });
                    
                    if (stop.latitude && stop.longitude) {
                        const lat = parseFloat(stop.latitude);
                        const lng = parseFloat(stop.longitude);
                        
                        if (isNaN(lat) || isNaN(lng)) {
                            console.warn(`‚ö†Ô∏è Stop ${index + 1} koordinatlarƒ± ge√ßersiz:`, lat, lng);
                            return;
                        }
                        
                        coordinates.push([lat, lng]);

                        // Durak marker'ƒ± olu≈ütur
                        const marker = L.circleMarker([lat, lng], {
                            radius: 8,
                            fillColor: routeColor,
                            color: '#ffffff',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.9
                        });

                        // Popup ekle
                        marker.bindPopup(`
                            <div class="popup-content">
                                <h6>${getRouteTypeIcon(route?.name || '')} ${stop.name || 'Durak ' + (index + 1)}</h6>
                                <p class="mb-1"><strong>Sƒ±ra:</strong> ${stop.order || index + 1}</p>
                                <p class="mb-1"><strong>Rota:</strong> ${route?.name || 'Bilinmiyor'}</p>
                                <p class="mb-0"><strong>Konum:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                            </div>
                        `);

                        currentRouteLayer.addLayer(marker);
                        console.log(`‚úÖ Stop ${index + 1} marker\'ƒ± eklendi:`, stop.name);
                    } else {
                        console.warn(`‚ö†Ô∏è Stop ${index + 1} koordinatlarƒ± eksik:`, stop);
                    }
                });

                // OSM ray + Backend stop hibrit sistemi
                if (coordinates.length > 1) {
                    await createRealRoutePolyline(coordinates, routeType, routeColor, route, stops);
                }

                // Layer'ƒ± haritaya ekle
                currentRouteLayer.addTo(map);

                // Haritayƒ± rota sƒ±nƒ±rlarƒ±na otomatik fit et
                if (coordinates.length > 0) {
                    const group = new L.featureGroup(currentRouteLayer.getLayers());
                    map.fitBounds(group.getBounds().pad(0.1));
                }

            } else {
                console.warn('Bu rota i√ßin durak bulunamadƒ±');
                alert('Bu rota i√ßin durak bilgisi bulunamadƒ±');
            }

        } catch (error) {
            console.error('Rota harita y√ºkleme hatasƒ±:', error);
            alert('Rota haritada g√∂sterilirken hata olu≈ütu: ' + error.message);
        }
    }

    // Rota t√ºr√ºn√º belirle
    function getRouteTypeFromName(routeName) {
        const name = routeName.toLowerCase();
        if (name.includes('metro') && !name.includes('metrob√ºs')) return 'metro';
        if (name.includes('tramvay') || name.includes('tram')) return 'tram';
        if (name.includes('metrob√ºs') || name.includes('metrobus')) return 'metrobus';
        return 'bus';
    }

    // Rota t√ºr√ºne g√∂re renk belirle
    function getRouteColor(routeType) {
        const colors = {
            'metro': '#dc3545',    // Kƒ±rmƒ±zƒ±
            'tram': '#17a2b8',     // Turkuaz
            'metrobus': '#28a745', // Ye≈üil
            'bus': '#007bff'       // Mavi
        };
        return colors[routeType] || colors.bus;
    }

    // Ara√ß t√ºr√ºne g√∂re hatlarƒ± getir
    function getRoutesByType(type) {
        const routes = {
            bus: [
                { id: 'bus-1', name: 'Hat 1', description: 'Kadƒ±k√∂y - Be≈üikta≈ü' },
                { id: 'bus-2', name: 'Hat 2', description: '√úsk√ºdar - ≈ûi≈üli' },
                { id: 'bus-3', name: 'Hat 3', description: 'Bakƒ±rk√∂y - Taksim' }
            ],
            metrobus: [
                { id: 'metrobus-1', name: 'Metrob√ºs 1', description: 'Avcƒ±lar - S√∂ƒü√ºtl√º√ße≈üme' },
                { id: 'metrobus-2', name: 'Metrob√ºs 2', description: 'Beylikd√ºz√º - Kadƒ±k√∂y' }
            ],
            metro: [
                { id: 'metro-1', name: 'M1', description: 'Yenikapƒ± - Havalimanƒ±' },
                { id: 'metro-2', name: 'M2', description: 'Hacƒ±osman - Yenikapƒ±' },
                { id: 'metro-3', name: 'M3', description: 'Kirazlƒ± - Bakƒ±rk√∂y' }
            ],
            tram: [
                { id: 'tram-1', name: 'T1', description: 'Baƒücƒ±lar - Kabata≈ü' },
                { id: 'tram-2', name: 'T2', description: 'Taksim - T√ºnel' }
            ]
        };
        
        return routes[type] || [];
    }

    // Ara√ßlarƒ± y√ºkle
    function loadVehicles(routeId) {
        const tableBody = document.getElementById('vehicleTableBody');
        tableBody.innerHTML = '';
        
        // √ñrnek ara√ß verileri
        const vehicles = [
            { id: '001', route: routeId, location: 'Kadƒ±k√∂y Duraƒüƒ±', speed: '25 km/h', status: 'active', eta: '5 dk' },
            { id: '002', route: routeId, location: 'Be≈üikta≈ü Duraƒüƒ±', speed: '0 km/h', status: 'stopped', eta: '10 dk' },
            { id: '003', route: routeId, location: 'Ortak√∂y Duraƒüƒ±', speed: '30 km/h', status: 'delayed', eta: '15 dk' }
        ];
        
        vehicles.forEach(vehicle => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><strong>${vehicle.id}</strong></td>
                <td>${vehicle.route}</td>
                <td>${vehicle.location}</td>
                <td>${vehicle.speed}</td>
                <td><span class="vehicle-status status-${vehicle.status}">${getStatusText(vehicle.status)}</span></td>
                <td>${vehicle.eta}</td>
            `;
            tableBody.appendChild(row);
        });
    }

    // Duraklarƒ± y√ºkle
    function loadStops(routeId) {
        const stopList = document.getElementById('stopList');
        stopList.innerHTML = '';
        
        // √ñrnek durak verileri
        const stops = [
            { name: 'Kadƒ±k√∂y', nextVehicle: '5 dk', status: 'active' },
            { name: 'Be≈üikta≈ü', nextVehicle: '10 dk', status: 'active' },
            { name: 'Ortak√∂y', nextVehicle: '15 dk', status: 'delayed' },
            { name: 'Taksim', nextVehicle: '20 dk', status: 'active' }
        ];
        
        stops.forEach(stop => {
            const stopItem = document.createElement('div');
            stopItem.className = 'col-md-6 col-lg-3 mb-3';
            stopItem.innerHTML = `
                <div class="stop-item ${stop.status === 'active' ? 'active' : ''}">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h6 class="mb-1">${stop.name}</h6>
                            <small class="text-muted">Sonraki ara√ß: ${stop.nextVehicle}</small>
                        </div>
                        <div>
                            <span class="vehicle-status status-${stop.status}">${getStatusText(stop.status)}</span>
                        </div>
                    </div>
                </div>
            `;
            stopList.appendChild(stopItem);
        });
    }

    // Durum metnini getir
    function getStatusText(status) {
        const statusTexts = {
            'active': 'Aktif',
            'delayed': 'Gecikmeli',
            'stopped': 'Durdu'
        };
        return statusTexts[status] || status;
    }



    // Haritayƒ± ba≈ülat
    function initializeMap() {
        if (map) {
            map.remove();
        }
        
        // ƒ∞stanbul koordinatlarƒ±
        map = L.map('map').setView([41.0082, 28.9784], 11);
        
        // OpenStreetMap tile layer ekle
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);
        
        // Eski checkbox event listener'larƒ± kaldƒ±r (artƒ±k kullanmƒ±yoruz)
        // Yeni sistemde sadece se√ßilen rota g√∂steriliyor
    }



    // Sayfa y√ºklendiƒüinde navbar'ƒ± g√ºncelle
    document.addEventListener('DOMContentLoaded', function() {
        if (window.updateNavbar) {
            window.updateNavbar();
        }
    });

    // OSM Ray + Backend Stop Hibrit Sistem
    async function createRealRoutePolyline(coordinates, routeType, routeColor, route, stops) {
        console.log('üöá OSM ray + Backend stop hibrit sistemi ba≈ülatƒ±lƒ±yor...', route?.name);
        
        try {
            // Loading g√∂ster
            showRouteLoading(true);
            
            // 1. Rota ismine g√∂re OSM'den ray verisi al
            const osmRailway = await getOSMRailwayByRouteName(route?.name, routeType);
            
            if (osmRailway && osmRailway.length > 0) {
                console.log('‚úÖ OSM\'den ray alƒ±ndƒ±:', osmRailway.length, 'nokta');
                
                // 2. OSM ray √ßizgisini √ßiz (ince √ßizgiler)
                const railwayLine = L.polyline(osmRailway, {
                    color: routeColor,
                    weight: routeType === 'metro' ? 3 : routeType === 'tram' ? 2.5 : 2,
                    opacity: 0.8,
                    smoothFactor: 1,
                    className: `route-line-${routeType} osm-railway`
                });

                railwayLine.bindPopup(`
                    <div class="popup-content">
                        <h6>${getRouteTypeIcon(route?.name || '')} ${route?.name || 'Rota'}</h6>
                        <p class="mb-1"><strong>Veri Kaynaƒüƒ±:</strong> OpenStreetMap</p>
                        <p class="mb-1"><strong>Ray Noktalarƒ±:</strong> ${osmRailway.length}</p>
                        <p class="mb-1"><strong>Backend Stoplarƒ±:</strong> ${stops?.length || coordinates.length}</p>
                        <p class="mb-0"><strong>Sistem:</strong> OSM Ray + Backend Stop</p>
                    </div>
                `);

                // Hover efektleri kaldƒ±rƒ±ldƒ± - √ßizgi kalƒ±nla≈ümasƒ±n
                
                currentRouteLayer.addLayer(railwayLine);
                console.log('‚úÖ OSM ray √ßizgisi haritaya eklendi!');
                
                // 3. Backend stoplarƒ±nƒ± ray √ºzerine yerle≈ütir (mevcut marker sistemi kullanƒ±lacak)
                console.log('üìç Backend stoplarƒ± ray √ºzerine yerle≈ütirilecek');
                
            } else {
                console.log('‚ö†Ô∏è OSM\'den ray bulunamadƒ±, sadece duraklar g√∂sterilecek');
            }
            
        } catch (error) {
            console.error('‚ùå OSM-Backend hibrit sistem hatasƒ±:', error);
            console.log('‚ö†Ô∏è Hata durumunda sadece durak noktalarƒ± g√∂sterilecek');
        } finally {
            showRouteLoading(false);
        }
    }

    // Loading indicator fonksiyonu
    function showRouteLoading(show) {
        const mapContainer = document.getElementById('trackingMap');
        let loadingDiv = document.getElementById('route-loading');
        
        if (show) {
            if (!loadingDiv) {
                loadingDiv = document.createElement('div');
                loadingDiv.id = 'route-loading';
                loadingDiv.className = 'route-loading';
                loadingDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> OSM\'den ray verisi alƒ±nƒ±yor...';
                mapContainer.appendChild(loadingDiv);
            }
            loadingDiv.style.display = 'block';
        } else {
            if (loadingDiv) {
                loadingDiv.style.display = 'none';
            }
        }
    }



    // Rota ismine g√∂re OSM'den ray verisi al (hƒ±zlƒ± fallback ile)
    async function getOSMRailwayByRouteName(routeName, routeType) {
        console.log('üîç OSM ray verisi aranƒ±yor:', routeName, routeType);
        
        if (!routeName) {
            console.log('‚ö†Ô∏è Rota ismi yok, OSM sorgusu yapƒ±lamƒ±yor');
            return null;
        }
        
        // Timeout s√ºresini artƒ±r
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('OSM timeout')), 20000)
        );
        
        try {
            // Rota ismine g√∂re arama terimleri olu≈ütur
            const searchTerms = generateOSMSearchTerms(routeName, routeType);
            const railwayTypes = getRailwayTypesForRoute(routeType);
            
            console.log('üîé OSM arama terimleri:', searchTerms);
            console.log('üöÇ Ray tipleri:', railwayTypes);
            
            // Hƒ±zlƒ± sorgu olu≈ütur
            const query = buildAdvancedOverpassQuery(routeName, routeType, searchTerms, railwayTypes);
            
            console.log('üì° OSM sorgusu ba≈ülatƒ±lƒ±yor (20 saniye timeout)');
            
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            // Race condition: 20 saniye timeout vs API √ßaƒürƒ±sƒ±
            const fetchPromise = fetch(overpassUrl, {
                method: 'POST',
                body: query,
                headers: { 'Content-Type': 'text/plain' }
            });
            
            const response = await Promise.race([fetchPromise, timeoutPromise]);
            
            if (!response.ok) {
                throw new Error(`Overpass API error: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('üìä OSM yanƒ±tƒ±:', data.elements?.length || 0, 'element');
            console.log('üîç OSM raw data:', data);
            
            if (data.elements && data.elements.length > 0) {
                // ƒ∞lk relation'ƒ± al (sorgu zaten sadece relation d√∂nd√ºr√ºyor)
                const railway = data.elements[0];
                
                console.log('‚úÖ OSM ray bulundu:', {
                    name: railway.tags?.name || 'ƒ∞simsiz',
                    type: railway.type,
                    id: railway.id,
                    tags: railway.tags,
                    hasGeometry: !!railway.geometry,
                    hasMembers: !!railway.members,
                    memberCount: railway.members?.length || 0
                });
                
                const coordinates = extractCoordinatesFromOSMElement(railway);
                if (coordinates && coordinates.length > 0) {
                    console.log('‚úÖ OSM ray koordinatlarƒ±:', coordinates.length, 'nokta');
                    console.log('üìç ƒ∞lk 3 koordinat:', coordinates.slice(0, 3));
                    console.log('üìç Son 3 koordinat:', coordinates.slice(-3));
                    return coordinates;
                } else {
                    console.error('‚ùå Koordinat √ßƒ±karma ba≈üarƒ±sƒ±z:', railway);
                }
            }
            
            console.log('‚ö†Ô∏è OSM\'den bu rota i√ßin ray bulunamadƒ±');
            return null;
            
        } catch (error) {
            if (error.message === 'OSM timeout') {
                console.warn('‚è∞ OSM sorgusu 20 saniyede timeout oldu');
            } else {
                console.error('‚ùå OSM ray verisi alma hatasƒ±:', error);
            }
            
            // Fallback: √áok basit sorgu dene
            return await trySimpleFallbackQuery(routeName, routeType);
        }
    }
    
    // √áok basit fallback sorgusu
    async function trySimpleFallbackQuery(routeName, routeType) {
        try {
            console.log('üîÑ Basit fallback sorgusu deneniyor...');
            
            let simpleQuery = `
                [out:json][timeout:8][bbox:40.8,28.7,41.3,29.3];
                (
            `;
            
            if (routeType === 'metro') {
                simpleQuery += `way["railway"="subway"];`;
            } else if (routeType === 'tram') {
                simpleQuery += `way["railway"="tram"];`;
            } else {
                simpleQuery += `relation["route"="bus"];`;
            }
            
            simpleQuery += `
                );
                out geom;
            `;
            
            const response = await fetch('https://overpass-api.de/api/interpreter', {
                method: 'POST',
                body: simpleQuery,
                headers: { 'Content-Type': 'text/plain' }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.elements && data.elements.length > 0) {
                    console.log('‚úÖ Fallback sorgusu ba≈üarƒ±lƒ±:', data.elements.length, 'element');
                    
                    // En uzun geometry'ye sahip way'i bul
                    let bestElement = null;
                    let maxGeometryLength = 0;
                    
                    data.elements.forEach((element, index) => {
                        const geometryLength = element.geometry?.length || 0;
                        console.log(`üîç Element ${index + 1}: ${element.type} ${element.id}, geometry: ${geometryLength} nokta, name: ${element.tags?.name || 'ƒ∞simsiz'}`);
                        
                        if (geometryLength > maxGeometryLength) {
                            maxGeometryLength = geometryLength;
                            bestElement = element;
                        }
                    });
                    
                    if (bestElement) {
                        console.log('üéØ En uzun element se√ßildi:', bestElement.id, 'geometry:', maxGeometryLength, 'nokta');
                        return extractCoordinatesFromOSMElement(bestElement);
                    } else {
                        // Fallback: ilk elementi al
                        const firstElement = data.elements[0];
                        return extractCoordinatesFromOSMElement(firstElement);
                    }
                }
            }
            
            console.log('‚ùå Fallback sorgusu da ba≈üarƒ±sƒ±z');
            return null;
            
        } catch (error) {
            console.error('‚ùå Fallback sorgusu hatasƒ±:', error);
            return null;
        }
    }
    
    // Rota ismine g√∂re OSM arama terimleri olu≈ütur
    function generateOSMSearchTerms(routeName, routeType) {
        const terms = [];
        const name = routeName.toLowerCase();
        
        // Rota ismini olduƒüu gibi ekle
        terms.push(routeName);
        
        if (routeType === 'metro') {
            // Metro hatlarƒ± i√ßin √∂zel terimler
            if (name.includes('m1')) terms.push('M1', 'M1A', 'M1B', 'Yenikapƒ±', 'Havalimanƒ±');
            if (name.includes('m2')) terms.push('M2', 'Hacƒ±osman', 'Yenikapƒ±', '≈ûi≈ühane');
            if (name.includes('m3')) terms.push('M3', 'Kirazlƒ±', 'Bakƒ±rk√∂y');
            if (name.includes('m4')) terms.push('M4', 'Kadƒ±k√∂y', 'Tav≈üantepe');
            if (name.includes('m5')) terms.push('M5', '√úsk√ºdar', '√áekmek√∂y');
            if (name.includes('m6')) terms.push('M6', 'Levent', 'Boƒüazi√ßi');
            if (name.includes('m7')) terms.push('M7', 'Kabata≈ü', 'Mecidiyek√∂y');
            
            // Genel metro terimleri
            if (name.includes('metro')) terms.push('Metro', 'ƒ∞stanbul Metro');
        } else if (routeType === 'tram') {
            // Tramvay hatlarƒ±
            if (name.includes('t1')) terms.push('T1', 'Baƒücƒ±lar', 'Kabata≈ü');
            if (name.includes('t4')) terms.push('T4', 'Topkapƒ±', 'Mescid-i Selam');
            if (name.includes('t5')) terms.push('T5', 'Alibeyk√∂y', 'Cibali');
            
            if (name.includes('tramvay')) terms.push('Tramvay', 'Tram');
        } else if (routeType === 'metrobus') {
            terms.push('Metrob√ºs', 'BRT', 'Avcƒ±lar', 'S√∂ƒü√ºtl√º√ße≈üme');
        }
        
        return [...new Set(terms)]; // Duplicate'leri kaldƒ±r
    }
    
    // Rota tipine g√∂re OSM railway tiplerini belirle
    function getRailwayTypesForRoute(routeType) {
        const types = {
            'metro': ['subway', 'metro'],
            'tram': ['tram', 'light_rail'],
            'metrobus': ['busway', 'bus'],
            'bus': ['bus']
        };
        return types[routeType] || ['bus'];
    }
    
    // Bu fonksiyon artƒ±k gerekli deƒüil - overpass sorgusu zaten spesifik sonu√ß d√∂nd√ºr√ºyor
    
    // OSM elementinden koordinatlarƒ± √ßƒ±kar (sadece ana ray √ßizgisi)
    function extractCoordinatesFromOSMElement(element) {
        console.log('üîß Koordinat √ßƒ±karma ba≈ülƒ±yor:', element.type, element.id);
        const coordinates = [];
        
        if (element.type === 'relation' && element.members) {
            console.log('üìã Relation i≈üleniyor, member sayƒ±sƒ±:', element.members.length);
            
            // Sadece ana ray √ßizgilerini al (platform, stop vs. hari√ß)
            const railwayMembers = element.members.filter(member => {
                // Sadece way tipindeki ve ray rol√ºndeki member'larƒ± al
                if (member.type !== 'way') return false;
                
                // Role kontrol√º - sadece ray √ßizgilerini al
                const role = member.role || '';
                if (role === 'platform' || role === 'stop' || role.includes('platform')) {
                    return false;
                }
                
                // Geometry var mƒ± kontrol et
                return !!member.geometry && member.geometry.length > 0;
            });
            
            console.log('üõ§Ô∏è Filtrelenmi≈ü ray member sayƒ±sƒ±:', railwayMembers.length);
            
            // Way member'larƒ±nƒ± sƒ±ralƒ± ≈üekilde birle≈ütir (tam rotayƒ± kapsasƒ±n)
            console.log('üîß Way member\'larƒ± sƒ±ralƒ± birle≈ütiriliyor...');
            
            // √ñnce t√ºm way geometrilerini topla
            const wayGeometries = [];
            railwayMembers.forEach((member, index) => {
                const geometryLength = member.geometry?.length || 0;
                console.log(`üë• Ray Member ${index + 1}:`, {
                    role: member.role || 'bo≈ü',
                    geometryLength: geometryLength,
                    id: member.ref
                });
                
                if (member.geometry && member.geometry.length > 0) {
                    const memberCoords = [];
                    member.geometry.forEach(point => {
                        if (point.lat && point.lon) {
                            memberCoords.push([point.lat, point.lon]);
                        }
                    });
                    if (memberCoords.length > 0) {
                        wayGeometries.push({
                            id: member.ref,
                            coords: memberCoords,
                            length: memberCoords.length
                        });
                    }
                }
            });
            
            console.log('üìä Toplanan way sayƒ±sƒ±:', wayGeometries.length);
            
            // Way'leri sƒ±ralƒ± birle≈ütir
            if (wayGeometries.length > 0) {
                // ƒ∞lk way'i ekle
                coordinates.push(...wayGeometries[0].coords);
                console.log('üöÄ ƒ∞lk way eklendi:', wayGeometries[0].coords.length, 'nokta');
                
                let usedWays = [0];
                let currentEnd = wayGeometries[0].coords[wayGeometries[0].coords.length - 1];
                
                // Geriye kalan way'leri sƒ±rayla baƒüla
                while (usedWays.length < wayGeometries.length) {
                    let bestMatch = -1;
                    let bestDistance = Infinity;
                    let shouldReverse = false;
                    
                    for (let i = 0; i < wayGeometries.length; i++) {
                        if (usedWays.includes(i)) continue;
                        
                        const way = wayGeometries[i];
                        const wayStart = way.coords[0];
                        const wayEnd = way.coords[way.coords.length - 1];
                        
                        // Mesafeleri hesapla
                        const distToStart = Math.abs(currentEnd[0] - wayStart[0]) + Math.abs(currentEnd[1] - wayStart[1]);
                        const distToEnd = Math.abs(currentEnd[0] - wayEnd[0]) + Math.abs(currentEnd[1] - wayEnd[1]);
                        
                        if (distToStart < bestDistance) {
                            bestDistance = distToStart;
                            bestMatch = i;
                            shouldReverse = false;
                        }
                        
                        if (distToEnd < bestDistance) {
                            bestDistance = distToEnd;
                            bestMatch = i;
                            shouldReverse = true;
                        }
                    }
                    
                    if (bestMatch !== -1) {
                        const nextWay = wayGeometries[bestMatch];
                        let nextCoords = [...nextWay.coords];
                        
                        if (shouldReverse) {
                            nextCoords.reverse();
                        }
                        
                        // ƒ∞lk noktayƒ± atlayarak ekle (√ßakƒ±≈ümayƒ± √∂nle)
                        coordinates.push(...nextCoords.slice(1));
                        currentEnd = nextCoords[nextCoords.length - 1];
                        usedWays.push(bestMatch);
                        
                        console.log(`üîó Way ${bestMatch + 1} baƒülandƒ± (${shouldReverse ? 'ters' : 'd√ºz'}):`, nextCoords.length - 1, 'yeni nokta');
                    } else {
                        console.warn('‚ö†Ô∏è Baƒülanabilecek way bulunamadƒ±, kalan way\'ler ekleniyor');
                        // Kalan way'leri olduƒüu gibi ekle
                        for (let i = 0; i < wayGeometries.length; i++) {
                            if (!usedWays.includes(i)) {
                                coordinates.push(...wayGeometries[i].coords);
                                usedWays.push(i);
                            }
                        }
                        break;
                    }
                }
            }
            
            console.log('üîó Sƒ±ralƒ± way birle≈ütirme tamamlandƒ±, toplam nokta:', coordinates.length);
            
            // Eƒüer hi√ß ray member'ƒ± yoksa t√ºm member'larƒ± dene
            if (coordinates.length === 0) {
                console.warn('‚ö†Ô∏è Ray member\'larƒ±nda koordinat yok, t√ºm member\'larƒ± deneniyor');
                element.members.forEach(member => {
                    if (member.geometry) {
                        member.geometry.forEach(point => {
                            if (point.lat && point.lon) {
                                coordinates.push([point.lat, point.lon]);
                            }
                        });
                    }
                });
            }
        } else if (element.geometry) {
            console.log('üõ§Ô∏è Way i≈üleniyor, geometri uzunluƒüu:', element.geometry.length);
            
            // Way geometrisinden koordinatlarƒ± al
            element.geometry.forEach(point => {
                if (point.lat && point.lon) {
                    coordinates.push([point.lat, point.lon]);
                }
            });
        } else {
            console.warn('‚ö†Ô∏è Element\'te ne geometry ne de members var:', element);
        }
        
        console.log('üìä √áƒ±karƒ±lan koordinat sayƒ±sƒ±:', coordinates.length);
        
        if (coordinates.length === 0) {
            console.error('‚ùå Hi√ß koordinat √ßƒ±karƒ±lamadƒ±!');
            return [];
        }
        
        // ƒ∞lk ve son nokta aynƒ±ysa son noktayƒ± kaldƒ±r (circle olmasƒ±n)
        if (coordinates.length > 2) {
            const firstPoint = coordinates[0];
            const lastPoint = coordinates[coordinates.length - 1];
            
            if (firstPoint && lastPoint && 
                Math.abs(firstPoint[0] - lastPoint[0]) < 0.0001 && 
                Math.abs(firstPoint[1] - lastPoint[1]) < 0.0001) {
                
                console.log('üîÑ ƒ∞lk ve son nokta aynƒ±, d√∂ng√º kƒ±rƒ±lƒ±yor');
                coordinates.pop(); // Son noktayƒ± kaldƒ±r
            }
        }
        
        console.log('‚úÖ Final koordinat sayƒ±sƒ±:', coordinates.length);
        return coordinates;
    }
    
    // Basit ve spesifik Overpass sorgu olu≈üturucu
    function buildAdvancedOverpassQuery(routeName, routeType, searchTerms, railwayTypes) {
        const name = routeName.toLowerCase();
        
        // Rota t√ºr√º ve ref'i belirle
        let routeTag = 'bus';  // default
        let railwayTag = null;
        let routeRef = null;
        
        if (routeType === 'metro') {
            routeTag = 'subway';
            railwayTag = 'subway';
            routeRef = extractMetroRef(name);
        } else if (routeType === 'tram') {
            routeTag = 'tram';
            railwayTag = 'tram';
            routeRef = extractTramRef(name);
        }
        
        // Basit ve direkt sorgu - sadece relation (sizin √∂rneƒüiniz gibi)
        let query = `
            [out:json][timeout:60];
            area["name"="ƒ∞stanbul"]->.searchArea;
        `;
        
        if (routeRef) {
            // Spesifik ref ile sadece relation
            query += `relation["route"="${routeTag}"]["ref"="${routeRef}"](area.searchArea);`;
        } else {
            // Genel arama - sadece relation
            if (railwayTag) {
                query += `relation["route"="${routeTag}"](area.searchArea);`;
            } else {
                query += `relation["route"="bus"]["operator"~"ƒ∞ETT|IETT",i](area.searchArea);`;
            }
        }
        
        query += `out geom;`;
        
        console.log('üîß Olu≈üturulan sorgu:');
        console.log('üìù Rota ismi:', routeName);
        console.log('üöÇ Rota t√ºr√º:', routeType);
        console.log('üè∑Ô∏è √áƒ±karƒ±lan ref:', routeRef);
        console.log('üìã Final sorgu:', query);
        return query;
    }
    
    // Metro hat referansƒ±nƒ± √ßƒ±kar (M1, M2, vb.)
    function extractMetroRef(routeName) {
        const metroMatch = routeName.match(/m(\d+[a-z]?)/i);
        if (metroMatch) {
            return 'M' + metroMatch[1].toUpperCase();
        }
        
        // Alternatif formatlar
        if (routeName.includes('yenikapƒ±') && routeName.includes('havalimanƒ±')) return 'M1A';
        if (routeName.includes('yenikapƒ±') && routeName.includes('kirazlƒ±')) return 'M1B';
        if (routeName.includes('hacƒ±osman')) return 'M2';
        if (routeName.includes('kirazlƒ±') && routeName.includes('bakƒ±rk√∂y')) return 'M3';
        if (routeName.includes('kadƒ±k√∂y')) return 'M4';
        if (routeName.includes('√ºsk√ºdar')) return 'M5';
        if (routeName.includes('levent')) return 'M6';
        if (routeName.includes('kabata≈ü') && routeName.includes('mecidiyek√∂y')) return 'M7';
        
        return null;
    }
    
    // Tramvay hat referansƒ±nƒ± √ßƒ±kar (T1, T4, vb.)
    function extractTramRef(routeName) {
        const tramMatch = routeName.match(/t(\d+)/i);
        if (tramMatch) {
            return 'T' + tramMatch[1];
        }
        
        // Alternatif formatlar
        if (routeName.includes('baƒücƒ±lar') && routeName.includes('kabata≈ü')) return 'T1';
        if (routeName.includes('topkapƒ±')) return 'T4';
        if (routeName.includes('alibeyk√∂y')) return 'T5';
        
        return null;
    }

    // Test fonksiyonlarƒ± - OSM Ray + Backend Stop hibrit sistem
    window.testOSMRouting = async function(routeName = 'M2 Metro Hattƒ±', routeType = 'metro') {
        console.log('üß™ OSM ray test ba≈ülƒ±yor...', routeName, routeType);
        
        const result = await getOSMRailwayByRouteName(routeName, routeType);
        
        if (result && result.length > 0) {
            console.log('‚úÖ OSM ray test ba≈üarƒ±lƒ±!', result.length, 'koordinat alƒ±ndƒ±');
            console.log('üìä ƒ∞lk 5 koordinat:', result.slice(0, 5));
            return result;
        } else {
            console.log('‚ùå OSM ray test ba≈üarƒ±sƒ±z!');
            return null;
        }
    };

    window.testHybridRoute = async function(routeName = 'Test Metro', routeType = 'metro') {
        console.log('üß™ Hibrit sistem test ba≈ülƒ±yor...', routeName, routeType);
        
        if (!map) {
            console.log('‚ùå √ñnce haritayƒ± ba≈ülatƒ±n!');
            return;
        }
        
        // Test i√ßin basit durak koordinatlarƒ±
        const testStops = [
            { name: 'Test Duraƒüƒ± 1', latitude: 41.0082, longitude: 28.9784, order: 1 },
            { name: 'Test Duraƒüƒ± 2', latitude: 41.0055, longitude: 29.0095, order: 2 },
            { name: 'Test Duraƒüƒ± 3', latitude: 41.0351, longitude: 28.9857, order: 3 }
        ];
        
        const testCoords = testStops.map(stop => [stop.latitude, stop.longitude]);
        
        await createRealRoutePolyline(testCoords, routeType, '#dc3545', { name: routeName }, testStops);
    };

    // Geli≈ümi≈ü sorgu test fonksiyonu
    window.testAdvancedQuery = function(routeName = 'M4', routeType = 'metro') {
        console.log('üîß Geli≈ümi≈ü sorgu test ediliyor...', routeName, routeType);
        
        const searchTerms = generateOSMSearchTerms(routeName, routeType);
        const railwayTypes = getRailwayTypesForRoute(routeType);
        const query = buildAdvancedOverpassQuery(routeName, routeType, searchTerms, railwayTypes);
        
        console.log('üìã Olu≈üturulan sorgu:');
        console.log(query);
        
        // Overpass Turbo linkini olu≈ütur
        const encodedQuery = encodeURIComponent(query);
        const overpassTurboUrl = `https://overpass-turbo.eu/?Q=${encodedQuery}`;
        console.log('üîó Overpass Turbo linki:', overpassTurboUrl);
        
        return { query, overpassTurboUrl };
    };
</script> 