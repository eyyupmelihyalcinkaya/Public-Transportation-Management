@{
    ViewData["Title"] = "Ara√ß Takip";
    Layout = "_Layout";
}

@section Styles {
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
}

@section Scripts {
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
}

<div class="container-fluid mt-4">
    <!-- Ba≈ülƒ±k -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card glass-card">
                <div class="card-body text-center">
                    <h2 class="card-title">
                        <i class="fas fa-bus text-primary"></i>
                        Ara√ß Takip Sistemi
                    </h2>
                    <p class="card-text text-muted">Metro ve tramvay ara√ßlarƒ±nƒ± ger√ßek zamanlƒ± takip edin</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Ara√ß T√ºr√º Se√ßimi -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card glass-card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-filter text-info"></i>
                        Ara√ß T√ºr√º Se√ßin
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <div class="vehicle-type-card modern-card" onclick="selectVehicleType('metro')">
                                <div class="vehicle-icon">
                                    <i class="fas fa-train text-warning"></i>
                                </div>
                                <h6>Metro</h6>
                                <small class="text-muted">Metro hatlarƒ±</small>
                            </div>
                        </div>
                        <div class="col-md-6 mb-3">
                            <div class="vehicle-type-card modern-card" onclick="selectVehicleType('tram')">
                                <div class="vehicle-icon">
                                    <i class="fas fa-train text-info"></i>
                                </div>
                                <h6>Tramvay</h6>
                                <small class="text-muted">Tramvay hatlarƒ±</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hat Se√ßimi -->
    <div class="row mb-4" id="routeSelection" style="display: none;">
        <div class="col-12">
            <div class="card glass-card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-route text-success"></i>
                        Hat Se√ßimi
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row" id="routeList">
                        <!-- Hatlar dinamik olarak y√ºklenecek -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ara√ß Takip Haritasƒ± -->
    <div class="row mb-4" id="trackingMap" style="display: none;">
        <div class="col-12">
            <div class="card glass-card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <div>
                        <h5 class="mb-0">
                            <i class="fas fa-map-marker-alt text-danger"></i>
                            Se√ßilen Rota Takibi
                        </h5>
                        <div class="text-muted">
                            <small>Se√ßilen rotanƒ±n duraklarƒ± ve g√ºzergahƒ± g√∂sterilmektedir</small>
                        </div>
                    </div>
                    <div class="d-flex gap-2">
                        <!-- Ara√ß Sim√ºlasyon Kontrolleri -->
                        <div class="btn-group" role="group" id="simulationControls" style="display: none;">
                            <button class="btn btn-success btn-sm" id="startSimulation" onclick="startVehicleSimulation()">
                                <i class="fas fa-play"></i> Ba≈ülat
                            </button>
                            <button class="btn btn-danger btn-sm" id="stopSimulation" onclick="stopVehicleSimulation()" style="display: none;">
                                <i class="fas fa-stop"></i> Durdur
                            </button>
                        </div>
                        <div class="dropdown" id="simulationSettings" style="display: none;">
                            <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                <i class="fas fa-cog"></i> Ayarlar
                            </button>
                            <ul class="dropdown-menu">
                                <li><h6 class="dropdown-header">Sim√ºlasyon Hƒ±zƒ±</h6></li>
                                <li><a class="dropdown-item" href="#" onclick="setSimulationSpeed(1)">1x Normal</a></li>
                                <li><a class="dropdown-item" href="#" onclick="setSimulationSpeed(2)">2x Hƒ±zlƒ±</a></li>
                                <li><a class="dropdown-item" href="#" onclick="setSimulationSpeed(5)">5x √áok Hƒ±zlƒ±</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><h6 class="dropdown-header">Durak Bekleme</h6></li>
                                <li><a class="dropdown-item" href="#" onclick="setStopDuration(2)">2 saniye</a></li>
                                <li><a class="dropdown-item" href="#" onclick="setStopDuration(5)">5 saniye</a></li>
                                <li><a class="dropdown-item" href="#" onclick="setStopDuration(10)">10 saniye</a></li>
                            </ul>
                        </div>
                        <button class="btn btn-outline-primary btn-sm" onclick="refreshMap()">
                            <i class="fas fa-sync-alt"></i> Yenile
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <div id="map" style="height: 500px; background: #f8f9fa; border-radius: 10px;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Ara√ß Listesi -->
    <div class="row mb-4" id="vehicleList" style="display: none;">
        <div class="col-12">
            <div class="card glass-card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-list text-info"></i>
                        Ara√ß Listesi
                    </h5>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-hover">
                            <thead>
                                <tr>
                                    <th>Ara√ß No</th>
                                    <th>Hat</th>
                                    <th>Konum</th>
                                    <th>Hƒ±z</th>
                                    <th>Durum</th>
                                    <th>Tahmini Varƒ±≈ü</th>
                                </tr>
                            </thead>
                            <tbody id="vehicleTableBody">
                                <!-- Ara√ßlar dinamik olarak y√ºklenecek -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    .glass-card {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .vehicle-type-card {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 15px;
        padding: 1.5rem;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }

    .vehicle-type-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s;
    }

    .vehicle-type-card:hover::before {
        left: 100%;
    }

    .vehicle-type-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        background: rgba(255, 255, 255, 0.2);
    }

    .vehicle-type-card.selected {
        background: rgba(13, 110, 253, 0.2);
        border-color: #0d6efd;
        box-shadow: 0 8px 25px rgba(13, 110, 253, 0.3);
    }

    /* Light tema i√ßin kartlar */
    body.light .vehicle-type-card {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: #333;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    body.light .vehicle-type-card:hover {
        background: rgba(255, 255, 255, 0.3);
        color: #000;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    body.light .vehicle-type-card.selected {
        background: rgba(13, 110, 253, 0.2);
        border-color: #0d6efd;
        color: #0d6efd;
    }

    /* Dark tema i√ßin kartlar */
    body.dark .vehicle-type-card {
        background: rgba(30, 41, 59, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        box-shadow: 0 4px 15px rgba(30, 41, 59, 0.4);
    }

    body.dark .vehicle-type-card:hover {
        background: rgba(30, 41, 59, 0.5);
        color: #fff;
        box-shadow: 0 8px 25px rgba(30, 41, 59, 0.6);
    }

    body.dark .vehicle-type-card.selected {
        background: rgba(13, 110, 253, 0.2);
        border-color: #0d6efd;
        color: #6ea8fe;
    }

    .vehicle-icon {
        font-size: 2.5rem;
        margin-bottom: 1rem;
    }

    .route-card {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 1.5rem;
        margin-bottom: 1rem;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
    }

    .route-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s;
    }

    .route-card:hover::before {
        left: 100%;
    }

    .route-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        background: rgba(255, 255, 255, 0.2);
    }

    .route-card.selected {
        background: rgba(25, 135, 84, 0.2);
        border-color: #198754;
        box-shadow: 0 6px 20px rgba(25, 135, 84, 0.3);
    }

    /* Light tema i√ßin route kartlarƒ± */
    body.light .route-card {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: #333;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }

    body.light .route-card:hover {
        background: rgba(255, 255, 255, 0.3);
        color: #000;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    body.light .route-card.selected {
        background: rgba(25, 135, 84, 0.2);
        border-color: #198754;
        color: #198754;
    }

    /* Dark tema i√ßin route kartlarƒ± */
    body.dark .route-card {
        background: rgba(30, 41, 59, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        box-shadow: 0 4px 15px rgba(30, 41, 59, 0.4);
    }

    body.dark .route-card:hover {
        background: rgba(30, 41, 59, 0.5);
        color: #fff;
        box-shadow: 0 8px 25px rgba(30, 41, 59, 0.6);
    }

    body.dark .route-card.selected {
        background: rgba(25, 135, 84, 0.2);
        border-color: #198754;
        color: #75b798;
    }

    .vehicle-status {
        padding: 0.5rem 1rem;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: 600;
        letter-spacing: 0.5px;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid transparent;
    }

    .status-active {
        background: rgba(25, 135, 84, 0.2);
        color: #198754;
        border-color: rgba(25, 135, 84, 0.3);
    }

    .status-active:hover {
        background: rgba(25, 135, 84, 0.3);
        transform: scale(1.05);
    }

    .status-delayed {
        background: rgba(255, 193, 7, 0.2);
        color: #ffc107;
        border-color: rgba(255, 193, 7, 0.3);
    }

    .status-delayed:hover {
        background: rgba(255, 193, 7, 0.3);
        transform: scale(1.05);
    }

    .status-stopped {
        background: rgba(220, 53, 69, 0.2);
        color: #dc3545;
        border-color: rgba(220, 53, 69, 0.3);
    }

    .status-stopped:hover {
        background: rgba(220, 53, 69, 0.3);
        transform: scale(1.05);
    }

    /* Light tema i√ßin durum g√∂stergeleri */
    body.light .vehicle-status {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    body.light .status-active {
        background: rgba(25, 135, 84, 0.2);
        color: #198754;
        border-color: rgba(25, 135, 84, 0.3);
    }

    body.light .status-delayed {
        background: rgba(255, 193, 7, 0.2);
        color: #e0a800;
        border-color: rgba(255, 193, 7, 0.3);
    }

    body.light .status-stopped {
        background: rgba(220, 53, 69, 0.2);
        color: #dc3545;
        border-color: rgba(220, 53, 69, 0.3);
    }

    /* Dark tema i√ßin durum g√∂stergeleri */
    body.dark .vehicle-status {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    body.dark .status-active {
        background: rgba(25, 135, 84, 0.2);
        color: #75b798;
        border-color: rgba(25, 135, 84, 0.3);
    }

    body.dark .status-delayed {
        background: rgba(255, 193, 7, 0.2);
        color: #ffca2c;
        border-color: rgba(255, 193, 7, 0.3);
    }

    body.dark .status-stopped {
        background: rgba(220, 53, 69, 0.2);
        color: #ea868f;
        border-color: rgba(220, 53, 69, 0.3);
    }

    .stop-item {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 0.5rem;
        transition: all 0.3s ease;
    }

    .stop-item:hover {
        background: rgba(255, 255, 255, 0.2);
    }

    .stop-item.active {
        background: rgba(13, 110, 253, 0.2);
        border-color: #0d6efd;
    }

    /* Harita popup stilleri */
    .popup-content {
        min-width: 200px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .popup-content h6 {
        margin-bottom: 0.5rem;
        color: #333;
        font-weight: 600;
        border-bottom: 1px solid #eee;
        padding-bottom: 0.25rem;
    }

    .popup-content p {
        font-size: 0.85rem;
        margin-bottom: 0.25rem;
    }

    .popup-content p:last-child {
        margin-bottom: 0;
    }

    /* Leaflet popup √∂zelle≈ütirme */
    .leaflet-popup-content-wrapper {
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .leaflet-popup-tip {
        background: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* OSM Ray √ßizgileri i√ßin stiller */
    .osm-railway {
        stroke-linecap: round;
        stroke-linejoin: round;
        filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
    }

    .osm-railway:hover {
        filter: drop-shadow(3px 3px 6px rgba(0, 0, 0, 0.4));
    }

    /* Loading indicator for OSM data */
    .route-loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        padding: 15px 25px;
        border-radius: 8px;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(5px);
    }

    .route-loading i {
        margin-right: 10px;
        color: #007bff;
    }
</style>

<script>
    let selectedVehicleType = '';
    let selectedRoute = '';
    let map = null;
    let routesData = [];
    let currentRouteLayer = null;

    // Ara√ß t√ºr√º se√ßimi - global scope'ta
    window.selectVehicleType = function(type) {
        selectedVehicleType = type;
        
        // T√ºm kartlarƒ±n se√ßimini kaldƒ±r
        document.querySelectorAll('.vehicle-type-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        // Se√ßilen kartƒ± i≈üaretle
        event.currentTarget.classList.add('selected');
        
        // Hat se√ßimini g√∂ster
        document.getElementById('routeSelection').style.display = 'block';
        
        // Hatlarƒ± y√ºkle
        loadRoutes(type);
    }

    // API'den rotalarƒ± y√ºkle
    async function loadRoutes(vehicleType) {
        const routeList = document.getElementById('routeList');
        routeList.innerHTML = '<div class="col-12 text-center"><i class="fas fa-spinner fa-spin"></i> Rotalar y√ºkleniyor...</div>';
        
        try {
            const response = await fetch('/User/GetPublicRoutes?page=1&pageSize=100');
            if (!response.ok) {
                throw new Error('Rotalar y√ºklenemedi');
            }
            
            const allRoutes = await response.json();
            routesData = allRoutes;
            
            // Se√ßilen ara√ß t√ºr√ºne g√∂re filtreleme
            const filteredRoutes = filterRoutesByType(allRoutes, vehicleType);
            
            routeList.innerHTML = '';
            
            if (filteredRoutes.length === 0) {
                routeList.innerHTML = `
                    <div class="col-12 text-center text-muted">
                        <i class="fas fa-info-circle mb-2"></i>
                        <p>Bu ara√ß t√ºr√º i√ßin rota bulunamadƒ±</p>
                    </div>
                `;
                return;
            }
            
            filteredRoutes.forEach(route => {
                const routeCard = document.createElement('div');
                routeCard.className = 'col-md-6 col-lg-4 mb-3';
                routeCard.innerHTML = `
                    <div class="route-card" onclick="selectRoute('${route.id}')">
                        <div class="d-flex align-items-center">
                            <div class="me-3">
                                <i class="fas fa-route text-primary"></i>
                            </div>
                            <div>
                                <h6 class="mb-1">${route.name}</h6>
                                <small class="text-muted">${route.startLocation} - ${route.endLocation}</small>
                                <br>
                                <small class="text-info">${getRouteTypeIcon(route.name)} ${getRouteTypeText(route.name)}</small>
                            </div>
                        </div>
                    </div>
                `;
                routeList.appendChild(routeCard);
            });
        } catch (error) {
            console.error('Rota y√ºkleme hatasƒ±:', error);
            routeList.innerHTML = `
                <div class="col-12 text-center text-danger">
                    <i class="fas fa-exclamation-triangle mb-2"></i>
                    <p>Rotalar y√ºklenirken hata olu≈ütu</p>
                </div>
            `;
        }
    }

    // Rota t√ºr√ºne g√∂re filtreleme
    function filterRoutesByType(routes, vehicleType) {
        return routes.filter(route => {
            const routeName = route.name.toLowerCase();
            switch (vehicleType) {
                case 'bus':
                    return routeName.includes('otob√ºs') || routeName.includes('bus') || 
                           (!routeName.includes('metro') && !routeName.includes('tramvay') && !routeName.includes('metrob√ºs'));
                case 'metro':
                    return routeName.includes('metro') && !routeName.includes('metrob√ºs');
                case 'tram':
                    return routeName.includes('tramvay') || routeName.includes('tram');
                case 'metrobus':
                    return routeName.includes('metrob√ºs') || routeName.includes('metrobus');
                default:
                    return true;
            }
        });
    }

    // Rota t√ºr√º ikonunu belirle
    function getRouteTypeIcon(routeName) {
        const name = routeName.toLowerCase();
        if (name.includes('metro') && !name.includes('metrob√ºs')) return '<i class="fas fa-train"></i>';
        if (name.includes('tramvay') || name.includes('tram')) return '<i class="fas fa-tram"></i>';
        if (name.includes('metrob√ºs') || name.includes('metrobus')) return '<i class="fas fa-subway"></i>';
        return '<i class="fas fa-bus"></i>';
    }

    // Rota t√ºr√º metnini belirle
    function getRouteTypeText(routeName) {
        const name = routeName.toLowerCase();
        if (name.includes('metro') && !name.includes('metrob√ºs')) return 'Metro';
        if (name.includes('tramvay') || name.includes('tram')) return 'Tramvay';
        if (name.includes('metrob√ºs') || name.includes('metrobus')) return 'Metrob√ºs';
        return 'Otob√ºs';
    }

    // Hat se√ßimi
    window.selectRoute = async function(routeId) {
        selectedRoute = routeId;
        
        // T√ºm hat kartlarƒ±nƒ±n se√ßimini kaldƒ±r
        document.querySelectorAll('.route-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        // Se√ßilen kartƒ± i≈üaretle
        event.currentTarget.classList.add('selected');
        
        // Takip sayfalarƒ±nƒ± g√∂ster
        document.getElementById('trackingMap').style.display = 'block';
        document.getElementById('vehicleList').style.display = 'block';
        
        // Haritayƒ± ba≈ülat
        initializeMap();
        
        // Se√ßilen rotayƒ± haritada g√∂ster
        await loadRouteOnMap(routeId);
        
        // Ara√ßlarƒ± y√ºkle
        loadVehicles(routeId);
    }

    // Se√ßilen rotayƒ± haritada g√∂ster
    async function loadRouteOnMap(routeId) {
        try {
            // √ñnceki rota layer'ƒ±nƒ± temizle
            if (currentRouteLayer) {
                map.removeLayer(currentRouteLayer);
            }

            // Rota duraklarƒ± verilerini al
            const response = await fetch(`/User/GetPublicRouteStops?routeId=${routeId}&page=1&pageSize=100`);
            if (!response.ok) {
                console.error('API Response Error:', response.status, response.statusText);
                const errorText = await response.text();
                console.error('Error details:', errorText);
                throw new Error(`Rota duraklarƒ± alƒ±namadƒ± (${response.status}): ${errorText}`);
            }

            const stops = await response.json();
            // Rota y√ºklendi
            if (stops && stops.length > 0) {
                // Rota bilgisini bul
                const route = routesData.find(r => r.id == routeId);
                // Rota bilgisi alƒ±ndƒ±
                const routeType = getRouteTypeFromName(route?.name || '');
                const routeColor = getRouteColor(routeType);

                // Yeni layer grup olu≈ütur
                currentRouteLayer = L.layerGroup();

                // Duraklarƒ± sƒ±rala
                const sortedStops = stops.sort((a, b) => (a.order || 0) - (b.order || 0));

                // Koordinatlarƒ± topla
                const coordinates = [];
                
                // Duraklarƒ± haritaya ekle
                sortedStops.forEach((stop, index) => {
                    if (stop.latitude && stop.longitude) {
                        const lat = parseFloat(stop.latitude);
                        const lng = parseFloat(stop.longitude);
                        
                        if (isNaN(lat) || isNaN(lng)) {
                            console.warn(`‚ö†Ô∏è Stop ${index + 1} koordinatlarƒ± ge√ßersiz:`, lat, lng);
                            return;
                        }
                        
                        coordinates.push([lat, lng]);

                        // Durak marker'ƒ± olu≈ütur
                        const marker = L.circleMarker([lat, lng], {
                            radius: 8,
                            fillColor: routeColor,
                            color: '#ffffff',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.9
                        });

                        // Popup ekle
                        marker.bindPopup(`
                            <div class="popup-content">
                                <h6>${getRouteTypeIcon(route?.name || '')} ${stop.name || 'Durak ' + (index + 1)}</h6>
                                <p class="mb-1"><strong>Sƒ±ra:</strong> ${stop.order || index + 1}</p>
                                <p class="mb-1"><strong>Rota:</strong> ${route?.name || 'Bilinmiyor'}</p>
                                <p class="mb-0"><strong>Konum:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}</p>
                            </div>
                        `);

                        currentRouteLayer.addLayer(marker);
                        // Stop marker eklendi
                    } else {
                        console.warn(`‚ö†Ô∏è Stop ${index + 1} koordinatlarƒ± eksik:`, stop);
                    }
                });

                // OSM ray + Backend stop hibrit sistemi
                if (coordinates.length > 1) {
                    await createRealRoutePolyline(coordinates, routeType, routeColor, route, stops);
                }

                // Layer'ƒ± haritaya ekle
                currentRouteLayer.addTo(map);

                // Haritayƒ± rota sƒ±nƒ±rlarƒ±na otomatik fit et
                if (coordinates.length > 0) {
                    const group = new L.featureGroup(currentRouteLayer.getLayers());
                    map.fitBounds(group.getBounds().pad(0.1));
                }

            } else {
                console.warn('Bu rota i√ßin durak bulunamadƒ±');
                alert('Bu rota i√ßin durak bilgisi bulunamadƒ±');
            }

        } catch (error) {
            console.error('Rota harita y√ºkleme hatasƒ±:', error);
            alert('Rota haritada g√∂sterilirken hata olu≈ütu: ' + error.message);
        }
    }

    // Rota t√ºr√ºn√º belirle
    function getRouteTypeFromName(routeName) {
        const name = routeName.toLowerCase();
        if (name.includes('metro') && !name.includes('metrob√ºs')) return 'metro';
        if (name.includes('tramvay') || name.includes('tram')) return 'tram';
        if (name.includes('metrob√ºs') || name.includes('metrobus')) return 'metrobus';
        return 'bus';
    }

    // Rota t√ºr√ºne g√∂re renk belirle
    function getRouteColor(routeType) {
        const colors = {
            'metro': '#dc3545',    // Kƒ±rmƒ±zƒ±
            'tram': '#17a2b8',     // Turkuaz
            'metrobus': '#28a745', // Ye≈üil
            'bus': '#007bff'       // Mavi
        };
        return colors[routeType] || colors.bus;
    }

    // Ara√ß t√ºr√ºne g√∂re hatlarƒ± getir
    function getRoutesByType(type) {
        const routes = {
            bus: [
                { id: 'bus-1', name: 'Hat 1', description: 'Kadƒ±k√∂y - Be≈üikta≈ü' },
                { id: 'bus-2', name: 'Hat 2', description: '√úsk√ºdar - ≈ûi≈üli' },
                { id: 'bus-3', name: 'Hat 3', description: 'Bakƒ±rk√∂y - Taksim' }
            ],
            metrobus: [
                { id: 'metrobus-1', name: 'Metrob√ºs 1', description: 'Avcƒ±lar - S√∂ƒü√ºtl√º√ße≈üme' },
                { id: 'metrobus-2', name: 'Metrob√ºs 2', description: 'Beylikd√ºz√º - Kadƒ±k√∂y' }
            ],
            metro: [
                { id: 'metro-1', name: 'M1', description: 'Yenikapƒ± - Havalimanƒ±' },
                { id: 'metro-2', name: 'M2', description: 'Hacƒ±osman - Yenikapƒ±' },
                { id: 'metro-3', name: 'M3', description: 'Kirazlƒ± - Bakƒ±rk√∂y' }
            ],
            tram: [
                { id: 'tram-1', name: 'T1', description: 'Baƒücƒ±lar - Kabata≈ü' },
                { id: 'tram-2', name: 'T2', description: 'Taksim - T√ºnel' }
            ]
        };
        
        return routes[type] || [];
    }

    // Ara√ßlarƒ± y√ºkle
    function loadVehicles(routeId) {
        const tableBody = document.getElementById('vehicleTableBody');
        tableBody.innerHTML = '';
        
        // √ñrnek ara√ß verileri
        const vehicles = [
            { id: '001', route: routeId, location: 'Kadƒ±k√∂y Duraƒüƒ±', speed: '25 km/h', status: 'active', eta: '5 dk' },
            { id: '002', route: routeId, location: 'Be≈üikta≈ü Duraƒüƒ±', speed: '0 km/h', status: 'stopped', eta: '10 dk' },
            { id: '003', route: routeId, location: 'Ortak√∂y Duraƒüƒ±', speed: '30 km/h', status: 'delayed', eta: '15 dk' }
        ];
        
        vehicles.forEach(vehicle => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><strong>${vehicle.id}</strong></td>
                <td>${vehicle.route}</td>
                <td>${vehicle.location}</td>
                <td>${vehicle.speed}</td>
                <td><span class="vehicle-status status-${vehicle.status}">${getStatusText(vehicle.status)}</span></td>
                <td>${vehicle.eta}</td>
            `;
            tableBody.appendChild(row);
        });
    }

    // Durum metnini getir
    function getStatusText(status) {
        const statusTexts = {
            'active': 'Aktif',
            'delayed': 'Gecikmeli',
            'stopped': 'Durdu'
        };
        return statusTexts[status] || status;
    }



    // Haritayƒ± ba≈ülat
    function initializeMap() {
        if (map) {
            map.remove();
        }
        
        // ƒ∞stanbul koordinatlarƒ±
        map = L.map('map').setView([41.0082, 28.9784], 11);
        
        // OpenStreetMap tile layer ekle
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);
        
        // Eski checkbox event listener'larƒ± kaldƒ±r (artƒ±k kullanmƒ±yoruz)
        // Yeni sistemde sadece se√ßilen rota g√∂steriliyor
    }



    // Sayfa y√ºklendiƒüinde navbar'ƒ± g√ºncelle
    document.addEventListener('DOMContentLoaded', function() {
        if (window.updateNavbar) {
            window.updateNavbar();
        }
    });

    // OSM Ray + Backend Stop Hibrit Sistem
    async function createRealRoutePolyline(coordinates, routeType, routeColor, route, stops) {
        // OSM ray sistemi ba≈ülatƒ±lƒ±yor
        
        try {
            // Loading g√∂ster
            showRouteLoading(true);
            
            // 1. Rota ismine g√∂re OSM'den ray verisi al
            const osmRailway = await getOSMRailwayByRouteName(route?.name, routeType);
            
            if (osmRailway && osmRailway.length > 0) {
                // OSM ray √ßizgisini √ßiz
                const railwayLine = L.polyline(osmRailway, {
                    color: routeColor,
                    weight: routeType === 'metro' ? 3 : routeType === 'tram' ? 2.5 : 2,
                    opacity: 0.8,
                    smoothFactor: 1,
                    className: `route-line-${routeType} osm-railway`
                });

                railwayLine.bindPopup(`
                    <div class="popup-content">
                        <h6>${getRouteTypeIcon(route?.name || '')} ${route?.name || 'Rota'}</h6>
                        <p class="mb-1"><strong>Veri Kaynaƒüƒ±:</strong> OpenStreetMap</p>
                        <p class="mb-1"><strong>Ray Noktalarƒ±:</strong> ${osmRailway.length}</p>
                        <p class="mb-1"><strong>Backend Stoplarƒ±:</strong> ${stops?.length || coordinates.length}</p>
                        <p class="mb-0"><strong>Sistem:</strong> OSM Ray + Backend Stop</p>
                    </div>
                `);
                
                currentRouteLayer.addLayer(railwayLine);
                
            } else {
                console.log('‚ö†Ô∏è OSM\'den ray bulunamadƒ±, sadece duraklar g√∂sterilecek');
            }
            
        } catch (error) {
            console.error('‚ùå OSM-Backend hibrit sistem hatasƒ±:', error);
            console.log('‚ö†Ô∏è Hata durumunda sadece durak noktalarƒ± g√∂sterilecek');
        } finally {
            showRouteLoading(false);
        }
    }

    // Loading indicator fonksiyonu
    function showRouteLoading(show) {
        const mapContainer = document.getElementById('trackingMap');
        let loadingDiv = document.getElementById('route-loading');
        
        if (show) {
            if (!loadingDiv) {
                loadingDiv = document.createElement('div');
                loadingDiv.id = 'route-loading';
                loadingDiv.className = 'route-loading';
                loadingDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i> OSM\'den ray verisi alƒ±nƒ±yor...';
                mapContainer.appendChild(loadingDiv);
            }
            loadingDiv.style.display = 'block';
        } else {
            if (loadingDiv) {
                loadingDiv.style.display = 'none';
            }
        }
    }



    // Rota ismine g√∂re OSM'den ray verisi al (hƒ±zlƒ± fallback ile)
    async function getOSMRailwayByRouteName(routeName, routeType) {
        console.log('üîç OSM ray verisi aranƒ±yor:', routeName, routeType);
        
        if (!routeName) {
            console.log('‚ö†Ô∏è Rota ismi yok, OSM sorgusu yapƒ±lamƒ±yor');
            return null;
        }
        
        // Timeout s√ºresini artƒ±r
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('OSM timeout')), 20000)
        );
        
        try {
            // Rota ismine g√∂re arama terimleri olu≈ütur
            const searchTerms = generateOSMSearchTerms(routeName, routeType);
            const railwayTypes = getRailwayTypesForRoute(routeType);
            
            console.log('üîé OSM arama terimleri:', searchTerms);
            console.log('üöÇ Ray tipleri:', railwayTypes);
            
            // Hƒ±zlƒ± sorgu olu≈ütur
            const query = buildAdvancedOverpassQuery(routeName, routeType, searchTerms, railwayTypes);
            
            console.log('üì° OSM sorgusu ba≈ülatƒ±lƒ±yor (20 saniye timeout)');
            
            const overpassUrl = 'https://overpass-api.de/api/interpreter';
            
            // Race condition: 20 saniye timeout vs API √ßaƒürƒ±sƒ±
            const fetchPromise = fetch(overpassUrl, {
                method: 'POST',
                body: query,
                headers: { 'Content-Type': 'text/plain' }
            });
            
            const response = await Promise.race([fetchPromise, timeoutPromise]);
            
            if (!response.ok) {
                throw new Error(`Overpass API error: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('üìä OSM yanƒ±tƒ±:', data.elements?.length || 0, 'element');
            console.log('üîç OSM raw data:', data);
            
            if (data.elements && data.elements.length > 0) {
                // ƒ∞lk relation'ƒ± al (sorgu zaten sadece relation d√∂nd√ºr√ºyor)
                const railway = data.elements[0];
                
                console.log('‚úÖ OSM ray bulundu:', {
                    name: railway.tags?.name || 'ƒ∞simsiz',
                    type: railway.type,
                    id: railway.id,
                    tags: railway.tags,
                    hasGeometry: !!railway.geometry,
                    hasMembers: !!railway.members,
                    memberCount: railway.members?.length || 0
                });
                
                const coordinates = extractCoordinatesFromOSMElement(railway);
                if (coordinates && coordinates.length > 0) {
                    console.log('‚úÖ OSM ray koordinatlarƒ±:', coordinates.length, 'nokta');
                    console.log('üìç ƒ∞lk 3 koordinat:', coordinates.slice(0, 3));
                    console.log('üìç Son 3 koordinat:', coordinates.slice(-3));
                    return coordinates;
                } else {
                    console.error('‚ùå Koordinat √ßƒ±karma ba≈üarƒ±sƒ±z:', railway);
                }
            }
            
            console.log('‚ö†Ô∏è OSM\'den bu rota i√ßin ray bulunamadƒ±');
            return null;
            
        } catch (error) {
            if (error.message === 'OSM timeout') {
                console.warn('‚è∞ OSM sorgusu 20 saniyede timeout oldu');
            } else {
                console.error('‚ùå OSM ray verisi alma hatasƒ±:', error);
            }
            
            // Fallback: √áok basit sorgu dene
            return await trySimpleFallbackQuery(routeName, routeType);
        }
    }
    
    // √áok basit fallback sorgusu
    async function trySimpleFallbackQuery(routeName, routeType) {
        try {
            console.log('üîÑ Basit fallback sorgusu deneniyor...');
            
            let simpleQuery = `
                [out:json][timeout:8][bbox:40.8,28.7,41.3,29.3];
                (
            `;
            
            if (routeType === 'metro') {
                simpleQuery += `way["railway"="subway"];`;
            } else if (routeType === 'tram') {
                simpleQuery += `way["railway"="tram"];`;
            } else {
                simpleQuery += `relation["route"="bus"];`;
            }
            
            simpleQuery += `
                );
                out geom;
            `;
            
            const response = await fetch('https://overpass-api.de/api/interpreter', {
                method: 'POST',
                body: simpleQuery,
                headers: { 'Content-Type': 'text/plain' }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.elements && data.elements.length > 0) {
                    console.log('‚úÖ Fallback sorgusu ba≈üarƒ±lƒ±:', data.elements.length, 'element');
                    
                    // En uzun geometry'ye sahip way'i bul
                    let bestElement = null;
                    let maxGeometryLength = 0;
                    
                    data.elements.forEach((element, index) => {
                        const geometryLength = element.geometry?.length || 0;
                        console.log(`üîç Element ${index + 1}: ${element.type} ${element.id}, geometry: ${geometryLength} nokta, name: ${element.tags?.name || 'ƒ∞simsiz'}`);
                        
                        if (geometryLength > maxGeometryLength) {
                            maxGeometryLength = geometryLength;
                            bestElement = element;
                        }
                    });
                    
                    if (bestElement) {
                        console.log('üéØ En uzun element se√ßildi:', bestElement.id, 'geometry:', maxGeometryLength, 'nokta');
                        return extractCoordinatesFromOSMElement(bestElement);
                    } else {
                        // Fallback: ilk elementi al
                        const firstElement = data.elements[0];
                        return extractCoordinatesFromOSMElement(firstElement);
                    }
                }
            }
            
            console.log('‚ùå Fallback sorgusu da ba≈üarƒ±sƒ±z');
            return null;
            
        } catch (error) {
            console.error('‚ùå Fallback sorgusu hatasƒ±:', error);
            return null;
        }
    }
    
    // Rota ismine g√∂re OSM arama terimleri olu≈ütur
    function generateOSMSearchTerms(routeName, routeType) {
        const terms = [];
        const name = routeName.toLowerCase();
        
        // Rota ismini olduƒüu gibi ekle
        terms.push(routeName);
        
        if (routeType === 'metro') {
            // Metro hatlarƒ± i√ßin √∂zel terimler
            if (name.includes('m1')) terms.push('M1', 'M1A', 'M1B', 'Yenikapƒ±', 'Havalimanƒ±');
            if (name.includes('m2')) terms.push('M2', 'Hacƒ±osman', 'Yenikapƒ±', '≈ûi≈ühane');
            if (name.includes('m3')) terms.push('M3', 'Kirazlƒ±', 'Bakƒ±rk√∂y');
            if (name.includes('m4')) terms.push('M4', 'Kadƒ±k√∂y', 'Tav≈üantepe');
            if (name.includes('m5')) terms.push('M5', '√úsk√ºdar', '√áekmek√∂y');
            if (name.includes('m6')) terms.push('M6', 'Levent', 'Boƒüazi√ßi');
            if (name.includes('m7')) terms.push('M7', 'Kabata≈ü', 'Mecidiyek√∂y');
            
            // Genel metro terimleri
            if (name.includes('metro')) terms.push('Metro', 'ƒ∞stanbul Metro');
        } else if (routeType === 'tram') {
            // Tramvay hatlarƒ±
            if (name.includes('t1')) terms.push('T1', 'Baƒücƒ±lar', 'Kabata≈ü');
            if (name.includes('t4')) terms.push('T4', 'Topkapƒ±', 'Mescid-i Selam');
            if (name.includes('t5')) terms.push('T5', 'Alibeyk√∂y', 'Cibali');
            
            if (name.includes('tramvay')) terms.push('Tramvay', 'Tram');
        } else if (routeType === 'metrobus') {
            terms.push('Metrob√ºs', 'BRT', 'Avcƒ±lar', 'S√∂ƒü√ºtl√º√ße≈üme');
        }
        
        return [...new Set(terms)]; // Duplicate'leri kaldƒ±r
    }
    
    // Rota tipine g√∂re OSM railway tiplerini belirle
    function getRailwayTypesForRoute(routeType) {
        const types = {
            'metro': ['subway', 'metro'],
            'tram': ['tram', 'light_rail'],
            'metrobus': ['busway', 'bus'],
            'bus': ['bus']
        };
        return types[routeType] || ['bus'];
    }
    
    // Bu fonksiyon artƒ±k gerekli deƒüil - overpass sorgusu zaten spesifik sonu√ß d√∂nd√ºr√ºyor
    
    // OSM elementinden koordinatlarƒ± √ßƒ±kar (sadece ana ray √ßizgisi)
    function extractCoordinatesFromOSMElement(element) {
        console.log('üîß Koordinat √ßƒ±karma ba≈ülƒ±yor:', element.type, element.id);
        const coordinates = [];
        
        if (element.type === 'relation' && element.members) {
            console.log('üìã Relation i≈üleniyor, member sayƒ±sƒ±:', element.members.length);
            
            // Sadece ana ray √ßizgilerini al (platform, stop vs. hari√ß)
            const railwayMembers = element.members.filter(member => {
                // Sadece way tipindeki ve ray rol√ºndeki member'larƒ± al
                if (member.type !== 'way') return false;
                
                // Role kontrol√º - sadece ray √ßizgilerini al
                const role = member.role || '';
                if (role === 'platform' || role === 'stop' || role.includes('platform')) {
                    return false;
                }
                
                // Geometry var mƒ± kontrol et
                return !!member.geometry && member.geometry.length > 0;
            });
            
            console.log('üõ§Ô∏è Filtrelenmi≈ü ray member sayƒ±sƒ±:', railwayMembers.length);
            
            // Way member'larƒ±nƒ± sƒ±ralƒ± ≈üekilde birle≈ütir (tam rotayƒ± kapsasƒ±n)
            console.log('üîß Way member\'larƒ± sƒ±ralƒ± birle≈ütiriliyor...');
            
            // √ñnce t√ºm way geometrilerini topla
            const wayGeometries = [];
            railwayMembers.forEach((member, index) => {
                const geometryLength = member.geometry?.length || 0;
                console.log(`üë• Ray Member ${index + 1}:`, {
                    role: member.role || 'bo≈ü',
                    geometryLength: geometryLength,
                    id: member.ref
                });
                
                if (member.geometry && member.geometry.length > 0) {
                    const memberCoords = [];
                    member.geometry.forEach(point => {
                        if (point.lat && point.lon) {
                            memberCoords.push([point.lat, point.lon]);
                        }
                    });
                    if (memberCoords.length > 0) {
                        wayGeometries.push({
                            id: member.ref,
                            coords: memberCoords,
                            length: memberCoords.length
                        });
                    }
                }
            });
            
            console.log('üìä Toplanan way sayƒ±sƒ±:', wayGeometries.length);
            
            // Way'leri sƒ±ralƒ± birle≈ütir
            if (wayGeometries.length > 0) {
                // ƒ∞lk way'i ekle
                coordinates.push(...wayGeometries[0].coords);
                console.log('üöÄ ƒ∞lk way eklendi:', wayGeometries[0].coords.length, 'nokta');
                
                let usedWays = [0];
                let currentEnd = wayGeometries[0].coords[wayGeometries[0].coords.length - 1];
                
                // Geriye kalan way'leri sƒ±rayla baƒüla
                while (usedWays.length < wayGeometries.length) {
                    let bestMatch = -1;
                    let bestDistance = Infinity;
                    let shouldReverse = false;
                    
                    for (let i = 0; i < wayGeometries.length; i++) {
                        if (usedWays.includes(i)) continue;
                        
                        const way = wayGeometries[i];
                        const wayStart = way.coords[0];
                        const wayEnd = way.coords[way.coords.length - 1];
                        
                        // Mesafeleri hesapla
                        const distToStart = Math.abs(currentEnd[0] - wayStart[0]) + Math.abs(currentEnd[1] - wayStart[1]);
                        const distToEnd = Math.abs(currentEnd[0] - wayEnd[0]) + Math.abs(currentEnd[1] - wayEnd[1]);
                        
                        if (distToStart < bestDistance) {
                            bestDistance = distToStart;
                            bestMatch = i;
                            shouldReverse = false;
                        }
                        
                        if (distToEnd < bestDistance) {
                            bestDistance = distToEnd;
                            bestMatch = i;
                            shouldReverse = true;
                        }
                    }
                    
                    if (bestMatch !== -1) {
                        const nextWay = wayGeometries[bestMatch];
                        let nextCoords = [...nextWay.coords];
                        
                        if (shouldReverse) {
                            nextCoords.reverse();
                        }
                        
                        // ƒ∞lk noktayƒ± atlayarak ekle (√ßakƒ±≈ümayƒ± √∂nle)
                        coordinates.push(...nextCoords.slice(1));
                        currentEnd = nextCoords[nextCoords.length - 1];
                        usedWays.push(bestMatch);
                        
                        console.log(`üîó Way ${bestMatch + 1} baƒülandƒ± (${shouldReverse ? 'ters' : 'd√ºz'}):`, nextCoords.length - 1, 'yeni nokta');
                    } else {
                        console.warn('‚ö†Ô∏è Baƒülanabilecek way bulunamadƒ±, kalan way\'ler ekleniyor');
                        // Kalan way'leri olduƒüu gibi ekle
                        for (let i = 0; i < wayGeometries.length; i++) {
                            if (!usedWays.includes(i)) {
                                coordinates.push(...wayGeometries[i].coords);
                                usedWays.push(i);
                            }
                        }
                        break;
                    }
                }
            }
            
            console.log('üîó Sƒ±ralƒ± way birle≈ütirme tamamlandƒ±, toplam nokta:', coordinates.length);
            
            // Eƒüer hi√ß ray member'ƒ± yoksa t√ºm member'larƒ± dene
            if (coordinates.length === 0) {
                console.warn('‚ö†Ô∏è Ray member\'larƒ±nda koordinat yok, t√ºm member\'larƒ± deneniyor');
                element.members.forEach(member => {
                    if (member.geometry) {
                        member.geometry.forEach(point => {
                            if (point.lat && point.lon) {
                                coordinates.push([point.lat, point.lon]);
                            }
                        });
                    }
                });
            }
        } else if (element.geometry) {
            console.log('üõ§Ô∏è Way i≈üleniyor, geometri uzunluƒüu:', element.geometry.length);
            
            // Way geometrisinden koordinatlarƒ± al
            element.geometry.forEach(point => {
                if (point.lat && point.lon) {
                    coordinates.push([point.lat, point.lon]);
                }
            });
        } else {
            console.warn('‚ö†Ô∏è Element\'te ne geometry ne de members var:', element);
        }
        
        console.log('üìä √áƒ±karƒ±lan koordinat sayƒ±sƒ±:', coordinates.length);
        
        if (coordinates.length === 0) {
            console.error('‚ùå Hi√ß koordinat √ßƒ±karƒ±lamadƒ±!');
            return [];
        }
        
        // ƒ∞lk ve son nokta aynƒ±ysa son noktayƒ± kaldƒ±r (circle olmasƒ±n)
        if (coordinates.length > 2) {
            const firstPoint = coordinates[0];
            const lastPoint = coordinates[coordinates.length - 1];
            
            if (firstPoint && lastPoint && 
                Math.abs(firstPoint[0] - lastPoint[0]) < 0.0001 && 
                Math.abs(firstPoint[1] - lastPoint[1]) < 0.0001) {
                
                console.log('üîÑ ƒ∞lk ve son nokta aynƒ±, d√∂ng√º kƒ±rƒ±lƒ±yor');
                coordinates.pop(); // Son noktayƒ± kaldƒ±r
            }
        }
        
        console.log('‚úÖ Final koordinat sayƒ±sƒ±:', coordinates.length);
        return coordinates;
    }
    
    // Basit ve spesifik Overpass sorgu olu≈üturucu
    function buildAdvancedOverpassQuery(routeName, routeType, searchTerms, railwayTypes) {
        const name = routeName.toLowerCase();
        
        // Rota t√ºr√º ve ref'i belirle
        let routeTag = 'bus';  // default
        let railwayTag = null;
        let routeRef = null;
        
        if (routeType === 'metro') {
            routeTag = 'subway';
            railwayTag = 'subway';
            routeRef = extractMetroRef(name);
        } else if (routeType === 'tram') {
            routeTag = 'tram';
            railwayTag = 'tram';
            routeRef = extractTramRef(name);
        }
        
        // Basit ve direkt sorgu - sadece relation (sizin √∂rneƒüiniz gibi)
        let query = `
            [out:json][timeout:60];
            area["name"="ƒ∞stanbul"]->.searchArea;
        `;
        
        if (routeRef) {
            // Spesifik ref ile sadece relation
            query += `relation["route"="${routeTag}"]["ref"="${routeRef}"](area.searchArea);`;
        } else {
            // Genel arama - sadece relation
            if (railwayTag) {
                query += `relation["route"="${routeTag}"](area.searchArea);`;
            } else {
                query += `relation["route"="bus"]["operator"~"ƒ∞ETT|IETT",i](area.searchArea);`;
            }
        }
        
        query += `out geom;`;
        
        console.log('üîß Olu≈üturulan sorgu:');
        console.log('üìù Rota ismi:', routeName);
        console.log('üöÇ Rota t√ºr√º:', routeType);
        console.log('üè∑Ô∏è √áƒ±karƒ±lan ref:', routeRef);
        console.log('üìã Final sorgu:', query);
        return query;
    }
    
    // Metro hat referansƒ±nƒ± √ßƒ±kar (M1, M2, vb.)
    function extractMetroRef(routeName) {
        const metroMatch = routeName.match(/m(\d+[a-z]?)/i);
        if (metroMatch) {
            return 'M' + metroMatch[1].toUpperCase();
        }
        
        // Alternatif formatlar
        if (routeName.includes('yenikapƒ±') && routeName.includes('havalimanƒ±')) return 'M1A';
        if (routeName.includes('yenikapƒ±') && routeName.includes('kirazlƒ±')) return 'M1B';
        if (routeName.includes('hacƒ±osman')) return 'M2';
        if (routeName.includes('kirazlƒ±') && routeName.includes('bakƒ±rk√∂y')) return 'M3';
        if (routeName.includes('kadƒ±k√∂y')) return 'M4';
        if (routeName.includes('√ºsk√ºdar')) return 'M5';
        if (routeName.includes('levent')) return 'M6';
        if (routeName.includes('kabata≈ü') && routeName.includes('mecidiyek√∂y')) return 'M7';
        
        return null;
    }
    
    // Tramvay hat referansƒ±nƒ± √ßƒ±kar (T1, T4, vb.)
    function extractTramRef(routeName) {
        const tramMatch = routeName.match(/t(\d+)/i);
        if (tramMatch) {
            return 'T' + tramMatch[1];
        }
        
        // Alternatif formatlar
        if (routeName.includes('baƒücƒ±lar') && routeName.includes('kabata≈ü')) return 'T1';
        if (routeName.includes('topkapƒ±')) return 'T4';
        if (routeName.includes('alibeyk√∂y')) return 'T5';
        
        return null;
    }

    // Test fonksiyonlarƒ± - OSM Ray + Backend Stop hibrit sistem
    window.testOSMRouting = async function(routeName = 'M2 Metro Hattƒ±', routeType = 'metro') {
        console.log('üß™ OSM ray test ba≈ülƒ±yor...', routeName, routeType);
        
        const result = await getOSMRailwayByRouteName(routeName, routeType);
        
        if (result && result.length > 0) {
            console.log('‚úÖ OSM ray test ba≈üarƒ±lƒ±!', result.length, 'koordinat alƒ±ndƒ±');
            console.log('üìä ƒ∞lk 5 koordinat:', result.slice(0, 5));
            return result;
        } else {
            console.log('‚ùå OSM ray test ba≈üarƒ±sƒ±z!');
            return null;
        }
    };

    window.testHybridRoute = async function(routeName = 'Test Metro', routeType = 'metro') {
        console.log('üß™ Hibrit sistem test ba≈ülƒ±yor...', routeName, routeType);
        
        if (!map) {
            console.log('‚ùå √ñnce haritayƒ± ba≈ülatƒ±n!');
            return;
        }
        
        // Test i√ßin basit durak koordinatlarƒ±
        const testStops = [
            { name: 'Test Duraƒüƒ± 1', latitude: 41.0082, longitude: 28.9784, order: 1 },
            { name: 'Test Duraƒüƒ± 2', latitude: 41.0055, longitude: 29.0095, order: 2 },
            { name: 'Test Duraƒüƒ± 3', latitude: 41.0351, longitude: 28.9857, order: 3 }
        ];
        
        const testCoords = testStops.map(stop => [stop.latitude, stop.longitude]);
        
        await createRealRoutePolyline(testCoords, routeType, '#dc3545', { name: routeName }, testStops);
    };

    // Geli≈ümi≈ü sorgu test fonksiyonu
    window.testAdvancedQuery = function(routeName = 'M4', routeType = 'metro') {
        console.log('üîß Geli≈ümi≈ü sorgu test ediliyor...', routeName, routeType);
        
        const searchTerms = generateOSMSearchTerms(routeName, routeType);
        const railwayTypes = getRailwayTypesForRoute(routeType);
        const query = buildAdvancedOverpassQuery(routeName, routeType, searchTerms, railwayTypes);
        
        console.log('üìã Olu≈üturulan sorgu:');
        console.log(query);
        
        // Overpass Turbo linkini olu≈ütur
        const encodedQuery = encodeURIComponent(query);
        const overpassTurboUrl = `https://overpass-turbo.eu/?Q=${encodedQuery}`;
        console.log('üîó Overpass Turbo linki:', overpassTurboUrl);
        
        return { query, overpassTurboUrl };
    };

    // ==================== √áOK ARA√áLI Sƒ∞M√úLASYON Sƒ∞STEMƒ∞ ====================
    
    // √áoklu ara√ß sim√ºlasyon sistemi
    let multiVehicleSimulation = {
        isRunning: false,
        vehicles: [], // Aktif ara√ßlar
        routeCoordinates: [],
        stopCoordinates: [], // Ger√ßek durak koordinatlarƒ±
        routeType: 'bus',
        routeName: '',
        maxVehicles: 5,
        minVehicles: 3,
        speed: 0.5,
        vehicleIntervals: [], // Her ara√ß i√ßin ayrƒ± interval
        hasShownStartNotification: false // Ba≈ülangƒ±√ß bildirimi g√∂sterildi mi?
    };

    // √áoklu ara√ß sim√ºlasyonunu ba≈ülat - Geli≈ütirilmi≈ü durak sistemi
    window.startVehicleSimulation = function() {
        if (!currentRouteLayer || !map) {
            alert('√ñnce bir rota se√ßin!');
            return;
        }

        // Rota koordinatlarƒ±nƒ± al
        const routeCoordinates = extractRouteCoordinates();
        if (!routeCoordinates || routeCoordinates.length < 2) {
            alert('Rota koordinatlarƒ± bulunamadƒ±!');
            return;
        }

        // Ger√ßek durak koordinatlarƒ±nƒ± al
        const stopCoordinates = extractStopCoordinates();
        if (!stopCoordinates || stopCoordinates.length < 2) {
            console.warn('Durak koordinatlarƒ± bulunamadƒ±, rota boyunca durak noktalarƒ± olu≈üturulacak');
        }

        // Sim√ºlasyon verilerini ayarla
        multiVehicleSimulation.routeCoordinates = routeCoordinates;
        multiVehicleSimulation.stopCoordinates = stopCoordinates || [];
        multiVehicleSimulation.isRunning = true;
        multiVehicleSimulation.routeType = getCurrentRouteType();
        multiVehicleSimulation.routeName = getCurrentRouteName();

        // Mevcut ara√ßlarƒ± temizle
        clearAllVehicles();

        // Rastgele sayƒ±da ara√ß olu≈ütur (3-5 arasƒ±)
        const vehicleCount = Math.floor(Math.random() * (multiVehicleSimulation.maxVehicles - multiVehicleSimulation.minVehicles + 1)) + multiVehicleSimulation.minVehicles;
        createMultipleVehicles(vehicleCount);

        // UI g√ºncellemeleri
        updateSimulationUI();
        showSimulationControls(true);

        // Her ara√ß i√ßin ayrƒ± animasyon ba≈ülat (asenkron hareket)
        startIndividualVehicleAnimations();
        
        // Ba≈ülangƒ±√ß bilgisi
        console.log('üöÄ Ara√ß sim√ºlasyonu ba≈ülatƒ±ldƒ±:', {
            routeType: multiVehicleSimulation.routeType,
            routeName: multiVehicleSimulation.routeName,
            vehicleCount: vehicleCount,
            routeCoordinates: routeCoordinates.length,
            stopCoordinates: multiVehicleSimulation.stopCoordinates.length
        });
        
        // Toast bildirimi (sadece sim√ºlasyon ba≈ülatƒ±ldƒ±ƒüƒ±nda, bir kez)
        if (!multiVehicleSimulation.hasShownStartNotification) {
            showToastNotification(
                'Sim√ºlasyon Ba≈ülatƒ±ldƒ±', 
                `${vehicleCount} ara√ß ${multiVehicleSimulation.routeName} rotasƒ±nda hareket etmeye ba≈üladƒ±.`, 
                'success'
            );
            multiVehicleSimulation.hasShownStartNotification = true;
        }
    };

    // Sim√ºlasyonu durdur (sadece durdur, pause yok)
    window.stopVehicleSimulation = function() {
        multiVehicleSimulation.isRunning = false;

        // T√ºm ara√ß interval'larƒ±nƒ± durdur
        multiVehicleSimulation.vehicleIntervals.forEach(interval => {
            if (interval) clearInterval(interval);
        });
        multiVehicleSimulation.vehicleIntervals = [];

        // T√ºm ara√ßlarƒ± temizle
        clearAllVehicles();

        // UI g√ºncellemeleri
        updateSimulationUI();
        showSimulationControls(false);
        
        // Sim√ºlasyon durdurma bildirimi (sadece bir kez)
        showToastNotification(
            'Sim√ºlasyon Durduruldu', 
            'Ara√ß sim√ºlasyonu durduruldu.', 
            'warning'
        );
    };

    // Pause fonksiyonunu kaldƒ±rdƒ±k (s√ºrekli √ßalƒ±≈üacak)
    window.pauseVehicleSimulation = function() {
        // Bu fonksiyon artƒ±k kullanƒ±lmƒ±yor
    };

    // Sim√ºlasyon hƒ±zƒ±nƒ± ayarla
    window.setSimulationSpeed = function(speed) {
        multiVehicleSimulation.speed = speed;
    };

    // Durak bekleme s√ºresini ayarla (artƒ±k kullanƒ±lmƒ±yor - random)
    window.setStopDuration = function(duration) {
        // Artƒ±k random 15-30 saniye kullanƒ±yoruz
    };

    // Mevcut rota t√ºr√ºn√º al
    function getCurrentRouteType() {
        if (!selectedRoute || !routesData) return 'bus';
        const route = routesData.find(r => r.id == selectedRoute);
        return getRouteTypeFromName(route?.name || '');
    }

    // Mevcut rota ismini al
    function getCurrentRouteName() {
        if (!selectedRoute || !routesData) return '';
        const route = routesData.find(r => r.id == selectedRoute);
        return route?.name || '';
    }

    // T√ºm ara√ßlarƒ± temizle
    function clearAllVehicles() {
        // Ara√ß interval'larƒ±nƒ± durdur
        multiVehicleSimulation.vehicleIntervals.forEach(interval => {
            if (interval) clearInterval(interval);
        });
        multiVehicleSimulation.vehicleIntervals = [];
        
        // Ara√ß marker'larƒ±nƒ± kaldƒ±r
        multiVehicleSimulation.vehicles.forEach(vehicle => {
            if (vehicle.marker) {
                map.removeLayer(vehicle.marker);
            }
        });
        multiVehicleSimulation.vehicles = [];
    }

    // √áoklu ara√ß olu≈ütur
    function createMultipleVehicles(count) {
        const routeLength = multiVehicleSimulation.routeCoordinates.length;
        const spacing = Math.floor(routeLength / count);

        for (let i = 0; i < count; i++) {
            const startIndex = (i * spacing) % routeLength;
            const vehicle = createSingleVehicle(i + 1, startIndex);
            multiVehicleSimulation.vehicles.push(vehicle);
        }
    }

    // Tek ara√ß olu≈ütur
    function createSingleVehicle(id, startIndex) {
        const position = multiVehicleSimulation.routeCoordinates[startIndex];
        const vehicleIcon = getVehicleIcon(multiVehicleSimulation.routeType);
        
        const marker = L.marker(position, { 
            icon: vehicleIcon,
            zIndexOffset: 1000 + id
        }).addTo(map);

        const vehicle = {
            id: id,
            marker: marker,
            currentIndex: startIndex,
            isAtStop: false,
            stopEndTime: 0,
            status: 'moving',
            speed: 'Normal',
            nextStop: getNextStopName(startIndex),
            interval: null, // Her ara√ß i√ßin ayrƒ± interval
            lastUpdateTime: Date.now(), // Son g√ºncelleme zamanƒ±
            direction: 1, // 1: ileri, -1: geri
            isReversing: false, // Geri d√∂n√º≈ü modunda mƒ±?
            hasShownStopNotification: false, // Durak bildirimi g√∂sterildi mi?
            lastStopIndex: -1 // Son durduƒüu durak indeksi
        };

        // Popup ekle (sadece tƒ±klama ile a√ßƒ±lsƒ±n)
        updateVehiclePopup(vehicle);
        
        return vehicle;
    }

    // Ara√ß t√ºr√ºne g√∂re ikon al
        function getVehicleIcon(routeType) {
        const icons = {
            'metro': '<i class="fas fa-train"></i>',
            'tram': '<i class="fas fa-subway"></i>',
            'metrobus': '<i class="fas fa-bus"></i>',
            'bus': '<i class="fas fa-bus-simple"></i>'
        };

        const colors = {
            'metro': '#dc3545',
            'tram': '#17a2b8',
            'metrobus': '#28a745',
            'bus': '#007bff'
        };

        const icon = icons[routeType] || '<i class="fas fa-bus"></i>';
        const color = colors[routeType] || '#007bff';

        return L.divIcon({
            html: `
                <div style="
                    background: ${color};
                    color: white;
                    border-radius: 50%;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border: 2px solid white;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                    font-size: 16px;
                ">
                    ${icon}
                </div>
            `,
            className: 'vehicle-marker',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
    }


    // Mevcut durak ismini al
    function getCurrentStopName(currentIndex) {
        if (multiVehicleSimulation.stopCoordinates.length === 0) {
            return 'Bilinmiyor';
        }
        
        const currentPosition = multiVehicleSimulation.routeCoordinates[currentIndex];
        const nearestStopIndex = findNearestStopIndex(currentPosition);
        
        // Durak isimleri
        const stopNames = [
            'Ba≈ülangƒ±√ß', 'Merkez', 'K√∂pr√º', 'ƒ∞stasyon', 'Terminal',
            'Pazar', 'Hastane', '√úniversite', 'Alƒ±≈üveri≈ü', 'Park',
            'Meydan', 'Cami', 'Okul', 'Belediye', 'Gar',
            'Havalimanƒ±', 'Liman', 'Fabrika', 'Depo', 'Son Durak'
        ];
        
        return stopNames[Math.min(nearestStopIndex, stopNames.length - 1)];
    }

    // Sonraki durak ismini al
    function getNextStopName(currentIndex) {
        if (multiVehicleSimulation.stopCoordinates.length === 0) {
            return 'Bilinmiyor';
        }
        
        const currentPosition = multiVehicleSimulation.routeCoordinates[currentIndex];
        const nearestStopIndex = findNearestStopIndex(currentPosition);
        
        // Durak isimleri
        const stopNames = [
            'Ba≈ülangƒ±√ß', 'Merkez', 'K√∂pr√º', 'ƒ∞stasyon', 'Terminal',
            'Pazar', 'Hastane', '√úniversite', 'Alƒ±≈üveri≈ü', 'Park',
            'Meydan', 'Cami', 'Okul', 'Belediye', 'Gar',
            'Havalimanƒ±', 'Liman', 'Fabrika', 'Depo', 'Son Durak'
        ];
        
        // Y√∂n durumuna g√∂re sonraki durak
        if (multiVehicleSimulation.vehicles.length > 0) {
            const vehicle = multiVehicleSimulation.vehicles.find(v => v.currentIndex === currentIndex);
            if (vehicle && vehicle.direction === -1) {
                // Geri gidiyorsa √∂nceki durak
                const nextStopIndex = Math.max(0, nearestStopIndex - 1);
                return stopNames[Math.min(nextStopIndex, stopNames.length - 1)];
            }
        }
        
        // ƒ∞leri gidiyorsa sonraki durak
        const nextStopIndex = Math.min(nearestStopIndex + 1, stopNames.length - 1);
        return stopNames[nextStopIndex];
    }

    // En yakƒ±n durak indeksini bul
    function findNearestStopIndex(position) {
        if (multiVehicleSimulation.stopCoordinates.length === 0) {
            return 0;
        }
        
        let nearestIndex = 0;
        let minDistance = Infinity;
        
        multiVehicleSimulation.stopCoordinates.forEach((stop, index) => {
            const [stopLat, stopLng] = stop;
            const latDiff = Math.abs(position[0] - stopLat);
            const lngDiff = Math.abs(position[1] - stopLng);
            const distance = latDiff + lngDiff; // Manhattan distance
            
            if (distance < minDistance) {
                minDistance = distance;
                nearestIndex = index;
            }
        });
        
        return nearestIndex;
    }

    // Rota koordinatlarƒ±nƒ± √ßƒ±kar
    function extractRouteCoordinates() {
        const coordinates = [];
        
        if (currentRouteLayer) {
            currentRouteLayer.eachLayer(layer => {
                // OSM ray √ßizgisini bul
                if (layer instanceof L.Polyline && layer.options.className && layer.options.className.includes('osm-railway')) {
                    const latLngs = layer.getLatLngs();
                    
                    // Polyline koordinatlarƒ±nƒ± d√ºz array'e d√∂n√º≈üt√ºr
                    if (Array.isArray(latLngs) && latLngs.length > 0) {
                        latLngs.forEach(latLng => {
                            if (latLng.lat && latLng.lng) {
                                coordinates.push([latLng.lat, latLng.lng]);
                            }
                        });
                    }
                    return; // ƒ∞lk OSM ray √ßizgisini bulduk, yeter
                }
                
                // Eƒüer OSM ray yoksa, durak marker'larƒ±nƒ± kullan (fallback)
                if (layer instanceof L.Marker && coordinates.length === 0) {
                    const latLng = layer.getLatLng();
                    coordinates.push([latLng.lat, latLng.lng]);
                }
            });
        }

        // Eƒüer hi√ß koordinat bulamadƒ±ysak, durak marker'larƒ±nƒ± topla
        if (coordinates.length === 0 && currentRouteLayer) {
            const stopMarkers = [];
            
            currentRouteLayer.eachLayer(layer => {
                if (layer instanceof L.Marker) {
                    const latLng = layer.getLatLng();
                    stopMarkers.push([latLng.lat, latLng.lng]);
                }
            });
            
            // Duraklarƒ± sƒ±rala (latitude'e g√∂re basit sƒ±ralama)
            stopMarkers.sort((a, b) => a[0] - b[0]);
            coordinates.push(...stopMarkers);
        }
        
        return coordinates;
    }

    // Ger√ßek durak koordinatlarƒ±nƒ± √ßƒ±kar - Geli≈ütirilmi≈ü durak algƒ±lama
    function extractStopCoordinates() {
        const stopCoords = [];
        
        if (currentRouteLayer) {
            currentRouteLayer.eachLayer(layer => {
                // Sadece durak marker'larƒ±nƒ± al (circle marker'lar)
                if (layer instanceof L.CircleMarker) {
                    const latLng = layer.getLatLng();
                    stopCoords.push([latLng.lat, latLng.lng]);
                    
                    // Durak bilgisini konsola yazdƒ±r
                    console.log('üöè Durak bulundu:', {
                        lat: latLng.lat,
                        lng: latLng.lng,
                        popup: layer.getPopup()?.getContent() || 'Bilinmiyor'
                    });
                }
            });
        }
        
        console.log('üìç Ger√ßek durak koordinatlarƒ±:', stopCoords.length, 'durak');
        
        // Eƒüer durak bulunamadƒ±ysa, rota koordinatlarƒ±ndan durak noktalarƒ± olu≈ütur
        if (stopCoords.length === 0) {
            console.warn('‚ö†Ô∏è Hi√ß durak bulunamadƒ±, rota koordinatlarƒ±ndan durak noktalarƒ± olu≈üturuluyor');
            const routeCoords = extractRouteCoordinates();
            if (routeCoords.length > 0) {
                // Rota boyunca e≈üit aralƒ±klarla durak noktalarƒ± olu≈ütur
                const stopCount = Math.min(10, Math.floor(routeCoords.length / 5));
                for (let i = 0; i < stopCount; i++) {
                    const index = Math.floor((i / (stopCount - 1)) * (routeCoords.length - 1));
                    stopCoords.push(routeCoords[index]);
                }
                console.log('üîÑ Olu≈üturulan durak noktalarƒ±:', stopCoords.length);
            }
        }
        
        return stopCoords;
    }

    // Global animasyon d√∂ng√ºs√ºn√º ba≈ülat - ARTIK KULLANILMIYOR
    // function startGlobalAnimation() {
    //     const interval = 1000 / multiVehicleSimulation.speed;
    //     multiVehicleSimulation.globalInterval = setInterval(() => {
    //         updateAllVehicles();
    //         updateVehicleList();
    //     }, interval);
    // }

    // T√ºm ara√ßlarƒ± g√ºncelle - ARTIK KULLANILMIYOR
    // function updateAllVehicles() {
    //     if (!multiVehicleSimulation.isRunning) return;
    //     multiVehicleSimulation.vehicles.forEach(vehicle => {
    //         updateSingleVehicle(vehicle);
    //     });
    // }

    // Tek aracƒ± g√ºncelle
    function updateSingleVehicle(vehicle) {
        const now = Date.now();
        
        // Durakta bekliyorsa
        if (vehicle.isAtStop) {
            if (now >= vehicle.stopEndTime) {
                vehicle.isAtStop = false;
                vehicle.status = vehicle.isReversing ? 'reversing' : 'moving';
                
                // Y√∂n durumuna g√∂re ikon ayarla
                if (vehicle.isReversing) {
                    vehicle.marker.setIcon(getReverseVehicleIcon(multiVehicleSimulation.routeType));
                } else {
                    vehicle.marker.setIcon(getVehicleIcon(multiVehicleSimulation.routeType));
                }
            } else {
                return; // Hala bekliyor
            }
        }

        // Hareket et
        const totalCoords = multiVehicleSimulation.routeCoordinates.length;
        const stepSize = Math.max(1, Math.floor(totalCoords / 200)); // Daha k√º√ß√ºk adƒ±mlar
        
        // Y√∂n kontrol√º - geri d√∂n√º≈ü sistemi
        if (vehicle.direction === 1) {
            // ƒ∞leri hareket
            vehicle.currentIndex += stepSize;
            
            // Rotanƒ±n sonuna geldi mi?
            if (vehicle.currentIndex >= totalCoords - 1) {
                vehicle.currentIndex = totalCoords - 1;
                vehicle.direction = -1; // Geri d√∂n√º≈ü ba≈ülat
                vehicle.isReversing = true;
                vehicle.status = 'reversing';
                
                // Geri d√∂n√º≈ü ikonu
                const reverseIcon = getReverseVehicleIcon(multiVehicleSimulation.routeType);
                vehicle.marker.setIcon(reverseIcon);
            }
        } else {
            // Geri hareket
            vehicle.currentIndex -= stepSize;
            
            // Rotanƒ±n ba≈üƒ±na geldi mi?
            if (vehicle.currentIndex <= 0) {
                vehicle.currentIndex = 0;
                vehicle.direction = 1; // ƒ∞leri hareket ba≈ülat
                vehicle.isReversing = false;
                vehicle.status = 'moving';
                
                // Normal ikon
                vehicle.marker.setIcon(getVehicleIcon(multiVehicleSimulation.routeType));
            }
        }
        
        const nextPosition = multiVehicleSimulation.routeCoordinates[vehicle.currentIndex];
        vehicle.marker.setLatLng(nextPosition);
        vehicle.nextStop = getNextStopName(vehicle.currentIndex);
        vehicle.lastUpdateTime = now;

        // Sadece ger√ßek duraklarda durma kontrol√º - Geli≈ütirilmi≈ü durak algƒ±lama
        if (multiVehicleSimulation.stopCoordinates.length > 0) {
            const isNearStop = checkIfNearStop(nextPosition);
            if (isNearStop && !vehicle.isAtStop) {
                startStopWait(vehicle);
            }
        } else {
            // Eƒüer durak koordinatlarƒ± yoksa, rota boyunca belirli noktalarda dur
            const totalCoords = multiVehicleSimulation.routeCoordinates.length;
            const stopInterval = Math.floor(totalCoords / 8); // 8 durak noktasƒ±
            
            if (stopInterval > 0 && vehicle.currentIndex % stopInterval === 0 && !vehicle.isAtStop) {
                // Rota boyunca e≈üit aralƒ±klarla durma
                startStopWait(vehicle);
            }
        }

        updateVehiclePopup(vehicle);
    }

    // Durak bekleme ba≈ülat - Geli≈ütirilmi≈ü durak bekleme sistemi
    function startStopWait(vehicle) {
        // Aynƒ± durakta tekrar durma kontrol√º
        const currentStopIndex = findNearestStopIndex(multiVehicleSimulation.routeCoordinates[vehicle.currentIndex]);
        if (vehicle.lastStopIndex === currentStopIndex) {
            return; // Aynƒ± durakta tekrar durma
        }
        
        vehicle.isAtStop = true;
        vehicle.status = 'at_stop';
        vehicle.lastStopIndex = currentStopIndex;
        
        // Her durakta 20-40 saniye arasƒ± random bekleme (daha ger√ßek√ßi)
        const waitTime = (20 + Math.random() * 20) * 1000;
        vehicle.stopEndTime = Date.now() + waitTime;

        // Durakta bekleyen ikon (y√∂n durumuna g√∂re)
        let waitingIcon;
        if (vehicle.isReversing) {
            waitingIcon = getWaitingReverseVehicleIcon(multiVehicleSimulation.routeType);
        } else {
            waitingIcon = getWaitingVehicleIcon(multiVehicleSimulation.routeType);
        }
        vehicle.marker.setIcon(waitingIcon);
        
        // Durak bilgisini g√ºncelle
        vehicle.nextStop = getCurrentStopName(vehicle.currentIndex);
        
        // Durakta durma bilgisini konsola yazdƒ±r (sadece debug i√ßin)
        if (console.log) {
            console.log('üõë Ara√ß #' + vehicle.id + ' duraƒüa geldi:', {
                currentStop: getCurrentStopName(vehicle.currentIndex),
                waitTime: Math.round(waitTime / 1000) + ' saniye',
                position: multiVehicleSimulation.routeCoordinates[vehicle.currentIndex]
            });
        }
        
        // Toast bildirimi g√∂ster (sadece √∂nemli duraklarda)
        const currentStopName = getCurrentStopName(vehicle.currentIndex);
        if (currentStopName.includes('Ba≈ülangƒ±√ß') || currentStopName.includes('Son Durak') || 
            currentStopName.includes('Merkez') || currentStopName.includes('Terminal')) {
            showToastNotification(
                'Ara√ß Duraƒüa Geldi', 
                `Ara√ß #${vehicle.id} ${currentStopName} duraƒüƒ±nda ${Math.round(waitTime / 1000)} saniye bekleyecek.`, 
                'info'
            );
        }
    }

    // Durakta bekleyen ara√ß ikonu
    function getWaitingVehicleIcon(routeType) {
        const icons = {
            'metro': '<i class="fas fa-train"></i>',
            'tram': '<i class="fas fa-subway"></i>',
            'metrobus': '<i class="fas fa-bus"></i>',
            'bus': '<i class="fas fa-bus-simple"></i>'
        };

        const icon = icons[routeType] || 'üöå';

        return L.divIcon({
            html: `
                <div style="
                    background: #ffc107;
                    color: white;
                    border-radius: 50%;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border: 2px solid white;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                    font-size: 14px;
                    animation: pulse 2s infinite;
                ">
                    ${icon}
                </div>
            `,
            className: 'vehicle-marker waiting',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
    }

    // Ara√ß popup'ƒ±nƒ± g√ºncelle
    function updateVehiclePopup(vehicle) {
        let statusText = 'Hareket halinde';
        let directionText = 'ƒ∞leri';
        
        if (vehicle.isAtStop) {
            statusText = 'Durakta';
        } else if (vehicle.isReversing) {
            statusText = 'Geri d√∂n√º≈ü';
            directionText = 'Geri';
        }
        
        const remainingTime = vehicle.isAtStop ? 
            Math.ceil((vehicle.stopEndTime - Date.now()) / 1000) : 0;

        // Mevcut durak bilgisi
        const currentStop = getCurrentStopName(vehicle.currentIndex);

        vehicle.marker.setPopupContent(`
            <div class="popup-content">
                <h6>Ara√ß #${vehicle.id}</h6>
                <p class="mb-1"><strong>Durum:</strong> ${statusText}</p>
                <p class="mb-1"><strong>Y√∂n:</strong> ${directionText}</p>
                <p class="mb-1"><strong>Hƒ±z:</strong> ${vehicle.speed}</p>
                <p class="mb-1"><strong>Mevcut Durak:</strong> ${currentStop}</p>
                <p class="mb-1"><strong>Sonraki Durak:</strong> ${vehicle.nextStop}</p>
                ${vehicle.isAtStop ? `<p class="mb-0"><strong>Kalan S√ºre:</strong> ${remainingTime}s</p>` : ''}
            </div>
        `);
    }

    // Dinamik ara√ß listesini g√ºncelle
    function updateVehicleList() {
        const vehicleTable = document.querySelector('#vehicleList tbody');
        if (!vehicleTable) return;

        vehicleTable.innerHTML = '';

        multiVehicleSimulation.vehicles.forEach(vehicle => {
            const row = document.createElement('tr');
            
            let statusClass = 'text-success';
            let statusText = 'Hareket halinde';
            
            if (vehicle.isAtStop) {
                statusClass = 'text-warning';
                statusText = 'Durakta';
            } else if (vehicle.isReversing) {
                statusClass = 'text-info';
                statusText = 'Geri d√∂n√º≈ü';
            }
            
            const eta = vehicle.isAtStop ? 
                Math.ceil((vehicle.stopEndTime - Date.now()) / 1000) + ' sn' : 
                '2-5 dk';

            // Mevcut durak bilgisi
            const currentStop = getCurrentStopName(vehicle.currentIndex);

            row.innerHTML = `
                <td>Ara√ß #${vehicle.id}</td>
                <td>${multiVehicleSimulation.routeName}</td>
                <td>${currentStop}</td>
                <td>${vehicle.speed}</td>
                <td><span class="badge ${statusClass}">${statusText}</span></td>
                <td>${eta}</td>
            `;
            vehicleTable.appendChild(row);
        });
    }

    // Sim√ºlasyon kontrolleri UI g√ºncellemeleri
    function updateSimulationUI() {
        const startBtn = document.getElementById('startSimulation');
        const stopBtn = document.getElementById('stopSimulation');

        if (!startBtn || !stopBtn) return; // Elementler yoksa √ßƒ±k

        if (multiVehicleSimulation.isRunning) {
            startBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
        } else {
            startBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
        }
    }

    // Sim√ºlasyon kontrollerini g√∂ster/gizle
    function showSimulationControls(show) {
        const controls = document.getElementById('simulationControls');
        const settings = document.getElementById('simulationSettings');
        
        if (show) {
            controls.style.display = 'block';
            settings.style.display = 'block';
        } else {
            controls.style.display = 'none';
            settings.style.display = 'none';
        }
    }

    // Bu fonksiyon artƒ±k kullanƒ±lmƒ±yor (s√ºrekli d√∂ng√º)

    // Toast bildirim sistemi - Geli≈ütirilmi≈ü (daha az popup)
    function showToastNotification(title, message, type = 'info') {
        // Toast container'ƒ± olu≈ütur (yoksa)
        let toastContainer = document.getElementById('toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.id = 'toast-container';
            toastContainer.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                max-width: 350px;
            `;
            document.body.appendChild(toastContainer);
        }

        // Aynƒ± mesajƒ±n tekrar g√∂sterilmesini engelle
        const existingToasts = toastContainer.querySelectorAll('.toast-message');
        for (let existingToast of existingToasts) {
            if (existingToast.textContent === message) {
                return; // Aynƒ± mesaj zaten g√∂steriliyor
            }
        }

        // Toast element'i olu≈ütur
        const toast = document.createElement('div');
        const toastId = 'toast-' + Date.now();
        toast.id = toastId;
        
        const bgColor = {
            'success': '#28a745',
            'info': '#17a2b8',
            'warning': '#ffc107',
            'error': '#dc3545'
        }[type] || '#17a2b8';

        toast.innerHTML = `
            <div class="toast-message" style="
                background: white;
                border-left: 4px solid ${bgColor};
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                margin-bottom: 10px;
                padding: 16px;
                position: relative;
                animation: slideIn 0.3s ease-out;
            ">
                <button onclick="closeToast('${toastId}')" style="
                    position: absolute;
                    top: 8px;
                    right: 8px;
                    background: none;
                    border: none;
                    font-size: 18px;
                    color: #6c757d;
                    cursor: pointer;
                    padding: 0;
                    width: 24px;
                    height: 24px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                ">&times;</button>
                <h6 style="margin: 0 20px 8px 0; color: ${bgColor}; font-weight: 600;">${title}</h6>
                <p style="margin: 0; color: #6c757d; font-size: 14px;">${message}</p>
            </div>
        `;

        // CSS animasyonu ekle (yoksa)
        if (!document.getElementById('toast-animations')) {
            const style = document.createElement('style');
            style.id = 'toast-animations';
            style.textContent = `
                @@keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @@keyframes slideOut {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(100%); opacity: 0; }
                }
                @@keyframes pulse {
                    0% { transform: scale(1); }
                    50% { transform: scale(1.1); }
                    100% { transform: scale(1); }
                }
            `;
            document.head.appendChild(style);
        }

        toastContainer.appendChild(toast);

        // 3 saniye sonra otomatik kapat (daha kƒ±sa s√ºre)
        setTimeout(() => {
            closeToast(toastId);
        }, 3000);
    }

    // Toast kapatma fonksiyonu
    window.closeToast = function(toastId) {
        const toast = document.getElementById(toastId);
        if (toast) {
            toast.style.animation = 'slideOut 0.3s ease-in';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }
    };

    // Rota se√ßildiƒüinde otomatik sim√ºlasyon ba≈ülat
    const originalSelectRoute = window.selectRoute;
    window.selectRoute = async function(routeId) {
        await originalSelectRoute(routeId);
        
        // 2 saniye sonra otomatik sim√ºlasyon ba≈ülat
        setTimeout(() => {
            showSimulationControls(true);
            updateSimulationUI();
            startVehicleSimulation(); // Otomatik ba≈ülat
        }, 2000);
    };

    // Her ara√ß i√ßin ayrƒ± animasyon ba≈ülat (asenkron hareket)
    function startIndividualVehicleAnimations() {
        multiVehicleSimulation.vehicles.forEach((vehicle, index) => {
            // Her ara√ß i√ßin farklƒ± hƒ±z (0.8x - 1.2x arasƒ±)
            const vehicleSpeed = multiVehicleSimulation.speed * (0.8 + Math.random() * 0.4);
            const interval = 1000 / vehicleSpeed;
            
            // Ara√ß i√ßin interval ba≈ülat
            const vehicleInterval = setInterval(() => {
                if (!multiVehicleSimulation.isRunning) {
                    clearInterval(vehicleInterval);
                    return;
                }
                
                updateSingleVehicle(vehicle);
                updateVehicleList(); // Ara√ß listesini g√ºncelle
            }, interval);
            
            // Interval'ƒ± kaydet
            vehicle.interval = vehicleInterval;
            multiVehicleSimulation.vehicleIntervals.push(vehicleInterval);
        });
    }

    // Geri d√∂n√º≈ü ara√ß ikonu
    function getReverseVehicleIcon(routeType) {
        const icons = {
            'metro': '<i class="fas fa-train"></i>',
            'tram': '<i class="fas fa-subway"></i>',
            'metrobus': '<i class="fas fa-bus"></i>',
            'bus': '<i class="fas fa-bus-simple"></i>'
        };

        const icon = icons[routeType] || 'üöå';

        return L.divIcon({
            html: `
                <div style="
                    background: #6f42c1;
                    color: white;
                    border-radius: 50%;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border: 2px solid white;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                    font-size: 14px;
                    animation: pulse 1.5s infinite;
                ">
                    ${icon}
                </div>
            `,
            className: 'vehicle-marker reverse',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
    }

    // Geri d√∂n√º≈ü durumunda bekleyen ara√ß ikonu
    function getWaitingReverseVehicleIcon(routeType) {
        const icons = {
            'metro': '<i class="fas fa-train"></i>',
            'tram': '<i class="fas fa-subway"></i>',
            'metrobus': '<i class="fas fa-bus"></i>',
            'bus': '<i class="fas fa-bus-simple"></i>'
        };

        const icon = icons[routeType] || 'üöå';

        return L.divIcon({
            html: `
                <div style="
                    background: #6f42c1;
                    color: white;
                    border-radius: 50%;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    border: 2px solid white;
                    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                    font-size: 14px;
                    animation: pulse 1.5s infinite;
                ">
                    ${icon}
                </div>
            `,
            className: 'vehicle-marker waiting reverse',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });
    }

    // Ara√ß bir duraƒüa yakƒ±n mƒ± kontrol et - Geli≈ütirilmi≈ü durak algƒ±lama
    function checkIfNearStop(position) {
        const stopRadius = 0.0005; // Yakla≈üƒ±k 50 metre (daha hassas durak algƒ±lama)
        
        return multiVehicleSimulation.stopCoordinates.some(stop => {
            const [stopLat, stopLng] = stop;
            const latDiff = Math.abs(position[0] - stopLat);
            const lngDiff = Math.abs(position[1] - stopLng);
            
            // Hem latitude hem longitude farkƒ± k√º√ß√ºkse duraƒüa yakƒ±n
            const isNearStop = latDiff < stopRadius && lngDiff < stopRadius;
            
            if (isNearStop) {
                console.log('üöè Durak algƒ±landƒ±:', {
                    vehiclePosition: position,
                    stopPosition: [stopLat, stopLng],
                    latDiff: latDiff,
                    lngDiff: lngDiff,
                    radius: stopRadius
                });
            }
            
            return isNearStop;
        });
    }

</script> 